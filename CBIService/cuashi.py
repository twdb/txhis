#
# Generated Wed May 05 13:34:56 2010 by generateDS.py version 1.20f.
#

import sys
import getopt
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class siteCode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, agencyCode=None, defaultId=None, siteID=None, network=None, agencyName=None, valueOf_=None):
        self.agencyCode = _cast(None, agencyCode)
        self.defaultId = _cast(bool, defaultId)
        self.siteID = _cast(None, siteID)
        self.network = _cast(None, network)
        self.agencyName = _cast(None, agencyName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if siteCode.subclass:
            return siteCode.subclass(*args_, **kwargs_)
        else:
            return siteCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agencyCode(self): return self.agencyCode
    def set_agencyCode(self, agencyCode): self.agencyCode = agencyCode
    def get_defaultId(self): return self.defaultId
    def set_defaultId(self, defaultId): self.defaultId = defaultId
    def get_siteID(self): return self.siteID
    def set_siteID(self, siteID): self.siteID = siteID
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def get_agencyName(self): return self.agencyName
    def set_agencyName(self, agencyName): self.agencyName = agencyName
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='siteCode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='siteCode')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='siteCode'):
        if self.agencyCode is not None:
            outfile.write(' agencyCode=%s' % (self.format_string(quote_attrib(self.agencyCode).encode(ExternalEncoding), input_name='agencyCode'), ))
        if self.defaultId is not None:
            outfile.write(' defaultId="%s"' % self.format_boolean(str_lower(str(self.defaultId)), input_name='defaultId'))
        if self.siteID is not None:
            outfile.write(' siteID=%s' % (self.format_string(quote_attrib(self.siteID).encode(ExternalEncoding), input_name='siteID'), ))
        outfile.write(' network=%s' % (self.format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
        if self.agencyName is not None:
            outfile.write(' agencyName=%s' % (self.format_string(quote_attrib(self.agencyName).encode(ExternalEncoding), input_name='agencyName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='siteCode'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='siteCode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.agencyCode is not None:
            showIndent(outfile, level)
            outfile.write('agencyCode = "%s",\n' % (self.agencyCode,))
        if self.defaultId is not None:
            showIndent(outfile, level)
            outfile.write('defaultId = %s,\n' % (self.defaultId,))
        if self.siteID is not None:
            showIndent(outfile, level)
            outfile.write('siteID = "%s",\n' % (self.siteID,))
        if self.network is not None:
            showIndent(outfile, level)
            outfile.write('network = "%s",\n' % (self.network,))
        if self.agencyName is not None:
            showIndent(outfile, level)
            outfile.write('agencyName = "%s",\n' % (self.agencyName,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('agencyCode'):
            self.agencyCode = attrs.get('agencyCode').value
        if attrs.get('defaultId'):
            if attrs.get('defaultId').value in ('true', '1'):
                self.defaultId = True
            elif attrs.get('defaultId').value in ('false', '0'):
                self.defaultId = False
            else:
                raise ValueError('Bad boolean attribute (defaultId)')
        if attrs.get('siteID'):
            self.siteID = attrs.get('siteID').value
        if attrs.get('network'):
            self.network = attrs.get('network').value
        if attrs.get('agencyName'):
            self.agencyName = attrs.get('agencyName').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class siteCode


class geoLocation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, geogLocation=None, localSiteXY=None):
        self.geogLocation = geogLocation
        if localSiteXY is None:
            self.localSiteXY = []
        else:
            self.localSiteXY = localSiteXY
    def factory(*args_, **kwargs_):
        if geoLocation.subclass:
            return geoLocation.subclass(*args_, **kwargs_)
        else:
            return geoLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_geogLocation(self): return self.geogLocation
    def set_geogLocation(self, geogLocation): self.geogLocation = geogLocation
    def get_localSiteXY(self): return self.localSiteXY
    def set_localSiteXY(self, localSiteXY): self.localSiteXY = localSiteXY
    def add_localSiteXY(self, value): self.localSiteXY.append(value)
    def insert_localSiteXY(self, index, value): self.localSiteXY[index] = value
    def export(self, outfile, level, namespace_='', name_='geoLocation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='geoLocation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='geoLocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='geoLocation'):
        if self.geogLocation:
            self.geogLocation.export(outfile, level, namespace_, name_='geogLocation', )
        for localSiteXY_ in self.localSiteXY:
            localSiteXY_.export(outfile, level, namespace_, name_='localSiteXY')
    def hasContent_(self):
        if (
            self.geogLocation is not None or
            self.localSiteXY
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='geoLocation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.geogLocation is not None:
            showIndent(outfile, level)
            outfile.write('geogLocation=model_.GeogLocationType(\n')
            self.geogLocation.exportLiteral(outfile, level, name_='geogLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('localSiteXY=[\n')
        level += 1
        for localSiteXY_ in self.localSiteXY:
            showIndent(outfile, level)
            outfile.write('model_.localSiteXY(\n')
            localSiteXY_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'geogLocation':
            obj_ = GeogLocationType.factory()
            obj_.build(child_)
            self.set_geogLocation(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'localSiteXY':
            obj_ = localSiteXY.factory()
            obj_.build(child_)
            self.localSiteXY.append(obj_)
# end class geoLocation


class localSiteXY(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, projectionInformation=None, X=None, Y=None, Z=None, note=None):
        self.projectionInformation = _cast(None, projectionInformation)
        self.X = X
        self.Y = Y
        self.Z = Z
        if note is None:
            self.note = []
        else:
            self.note = note
    def factory(*args_, **kwargs_):
        if localSiteXY.subclass:
            return localSiteXY.subclass(*args_, **kwargs_)
        else:
            return localSiteXY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_Z(self): return self.Z
    def set_Z(self, Z): self.Z = Z
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def get_projectionInformation(self): return self.projectionInformation
    def set_projectionInformation(self, projectionInformation): self.projectionInformation = projectionInformation
    def export(self, outfile, level, namespace_='', name_='localSiteXY', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='localSiteXY')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='localSiteXY'):
        if self.projectionInformation is not None:
            outfile.write(' projectionInformation=%s' % (self.format_string(quote_attrib(self.projectionInformation).encode(ExternalEncoding), input_name='projectionInformation'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='localSiteXY'):
        if self.X is not None:
            showIndent(outfile, level)
            outfile.write('<%sX>%s</%sX>\n' % (namespace_, self.format_string(quote_xml(self.X).encode(ExternalEncoding), input_name='X'), namespace_))
        if self.Y is not None:
            showIndent(outfile, level)
            outfile.write('<%sY>%s</%sY>\n' % (namespace_, self.format_string(quote_xml(self.Y).encode(ExternalEncoding), input_name='Y'), namespace_))
        if self.Z is not None:
            showIndent(outfile, level)
            outfile.write('<%sZ>%s</%sZ>\n' % (namespace_, self.format_string(quote_xml(self.Z).encode(ExternalEncoding), input_name='Z'), namespace_))
        for note_ in self.note:
            note_.export(outfile, level, namespace_, name_='note')
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.Z is not None or
            self.note
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='localSiteXY'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.projectionInformation is not None:
            showIndent(outfile, level)
            outfile.write('projectionInformation = "%s",\n' % (self.projectionInformation,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.X is not None:
            showIndent(outfile, level)
            outfile.write('X=%s,\n' % quote_python(self.X).encode(ExternalEncoding))
        if self.Y is not None:
            showIndent(outfile, level)
            outfile.write('Y=%s,\n' % quote_python(self.Y).encode(ExternalEncoding))
        if self.Z is not None:
            showIndent(outfile, level)
            outfile.write('Z=%s,\n' % quote_python(self.Z).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('model_.NoteType(\n')
            note_.exportLiteral(outfile, level, name_='NoteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('projectionInformation'):
            self.projectionInformation = attrs.get('projectionInformation').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'X':
            X_ = ''
            for text__content_ in child_.childNodes:
                X_ += text__content_.nodeValue
            self.X = X_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Y':
            Y_ = ''
            for text__content_ in child_.childNodes:
                Y_ += text__content_.nodeValue
            self.Y = Y_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Z':
            Z_ = ''
            for text__content_ in child_.childNodes:
                Z_ += text__content_.nodeValue
            self.Z = Z_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'note':
            obj_ = NoteType.factory()
            obj_.build(child_)
            self.note.append(obj_)
# end class localSiteXY


class TsValuesSingleVariableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, unitsAbbreviation=None, unitsType=None, timeZoneShiftApplied=None, unitsAreConverted=False, unitsCode=None, value=None, qualifier=None, qualityControlLevel=None, method=None, source=None, offset=None):
        self.count = _cast(int, count)
        self.unitsAbbreviation = _cast(None, unitsAbbreviation)
        self.unitsType = _cast(None, unitsType)
        self.timeZoneShiftApplied = _cast(bool, timeZoneShiftApplied)
        self.unitsAreConverted = _cast(bool, unitsAreConverted)
        self.unitsCode = _cast(None, unitsCode)
        if value is None:
            self.value = []
        else:
            self.value = value
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
        if qualityControlLevel is None:
            self.qualityControlLevel = []
        else:
            self.qualityControlLevel = qualityControlLevel
        if method is None:
            self.method = []
        else:
            self.method = method
        if source is None:
            self.source = []
        else:
            self.source = source
        if offset is None:
            self.offset = []
        else:
            self.offset = offset
    def factory(*args_, **kwargs_):
        if TsValuesSingleVariableType.subclass:
            return TsValuesSingleVariableType.subclass(*args_, **kwargs_)
        else:
            return TsValuesSingleVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def add_qualifier(self, value): self.qualifier.append(value)
    def insert_qualifier(self, index, value): self.qualifier[index] = value
    def get_qualityControlLevel(self): return self.qualityControlLevel
    def set_qualityControlLevel(self, qualityControlLevel): self.qualityControlLevel = qualityControlLevel
    def add_qualityControlLevel(self, value): self.qualityControlLevel.append(value)
    def insert_qualityControlLevel(self, index, value): self.qualityControlLevel[index] = value
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def add_method(self, value): self.method.append(value)
    def insert_method(self, index, value): self.method[index] = value
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def add_source(self, value): self.source.append(value)
    def insert_source(self, index, value): self.source[index] = value
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def add_offset(self, value): self.offset.append(value)
    def insert_offset(self, index, value): self.offset[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_unitsAbbreviation(self): return self.unitsAbbreviation
    def set_unitsAbbreviation(self, unitsAbbreviation): self.unitsAbbreviation = unitsAbbreviation
    def get_unitsType(self): return self.unitsType
    def set_unitsType(self, unitsType): self.unitsType = unitsType
    def validate_UnitsTypeEnum(self, value):
        # Validate type UnitsTypeEnum, a restriction on xsi:string.
        pass
    def get_timeZoneShiftApplied(self): return self.timeZoneShiftApplied
    def set_timeZoneShiftApplied(self, timeZoneShiftApplied): self.timeZoneShiftApplied = timeZoneShiftApplied
    def get_unitsAreConverted(self): return self.unitsAreConverted
    def set_unitsAreConverted(self, unitsAreConverted): self.unitsAreConverted = unitsAreConverted
    def get_unitsCode(self): return self.unitsCode
    def set_unitsCode(self, unitsCode): self.unitsCode = unitsCode
    def export(self, outfile, level, namespace_='', name_='TsValuesSingleVariableType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TsValuesSingleVariableType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='TsValuesSingleVariableType'):
        if self.count is not None:
            outfile.write(' count="%s"' % self.format_integer(self.count, input_name='count'))
        if self.unitsAbbreviation is not None:
            outfile.write(' unitsAbbreviation=%s' % (self.format_string(quote_attrib(self.unitsAbbreviation).encode(ExternalEncoding), input_name='unitsAbbreviation'), ))
        if self.unitsType is not None:
            outfile.write(' unitsType=%s' % (quote_attrib(self.unitsType), ))
        if self.timeZoneShiftApplied is not None:
            outfile.write(' timeZoneShiftApplied="%s"' % self.format_boolean(str_lower(str(self.timeZoneShiftApplied)), input_name='timeZoneShiftApplied'))
        if self.unitsAreConverted is not None:
            outfile.write(' unitsAreConverted="%s"' % self.format_boolean(str_lower(str(self.unitsAreConverted)), input_name='unitsAreConverted'))
        if self.unitsCode is not None:
            outfile.write(' unitsCode=%s' % (self.format_string(quote_attrib(self.unitsCode).encode(ExternalEncoding), input_name='unitsCode'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TsValuesSingleVariableType'):
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value')
        for qualifier_ in self.qualifier:
            qualifier_.export(outfile, level, namespace_, name_='qualifier')
        for qualityControlLevel_ in self.qualityControlLevel:
            qualityControlLevel_.export(outfile, level, namespace_, name_='qualityControlLevel')
        for method_ in self.method:
            method_.export(outfile, level, namespace_, name_='method')
        for source_ in self.source:
            source_.export(outfile, level, namespace_, name_='source')
        for offset_ in self.offset:
            offset_.export(outfile, level, namespace_, name_='offset')
    def hasContent_(self):
        if (
            self.value or
            self.qualifier or
            self.qualityControlLevel or
            self.method or
            self.source or
            self.offset
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TsValuesSingleVariableType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.count is not None:
            showIndent(outfile, level)
            outfile.write('count = %d,\n' % (self.count,))
        if self.unitsAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('unitsAbbreviation = "%s",\n' % (self.unitsAbbreviation,))
        if self.unitsType is not None:
            showIndent(outfile, level)
            outfile.write('unitsType = "%s",\n' % (self.unitsType,))
        if self.timeZoneShiftApplied is not None:
            showIndent(outfile, level)
            outfile.write('timeZoneShiftApplied = %s,\n' % (self.timeZoneShiftApplied,))
        if self.unitsAreConverted is not None:
            showIndent(outfile, level)
            outfile.write('unitsAreConverted = %s,\n' % (self.unitsAreConverted,))
        if self.unitsCode is not None:
            showIndent(outfile, level)
            outfile.write('unitsCode = "%s",\n' % (self.unitsCode,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.ValueSingleVariable(\n')
            value_.exportLiteral(outfile, level, name_='ValueSingleVariable')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('qualifier=[\n')
        level += 1
        for qualifier_ in self.qualifier:
            showIndent(outfile, level)
            outfile.write('model_.qualifier(\n')
            qualifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('qualityControlLevel=[\n')
        level += 1
        for qualityControlLevel_ in self.qualityControlLevel:
            showIndent(outfile, level)
            outfile.write('model_.qualityControlLevel(\n')
            qualityControlLevel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('method=[\n')
        level += 1
        for method_ in self.method:
            showIndent(outfile, level)
            outfile.write('model_.MethodType(\n')
            method_.exportLiteral(outfile, level, name_='MethodType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('source=[\n')
        level += 1
        for source_ in self.source:
            showIndent(outfile, level)
            outfile.write('model_.SourceType(\n')
            source_.exportLiteral(outfile, level, name_='SourceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('offset=[\n')
        level += 1
        for offset_ in self.offset:
            showIndent(outfile, level)
            outfile.write('model_.OffsetType(\n')
            offset_.exportLiteral(outfile, level, name_='OffsetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('count'):
            try:
                self.count = int(attrs.get('count').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (count): %s' % exp)
            if self.count < 0:
                raise ValueError('Invalid NonNegativeInteger (count)')
        if attrs.get('unitsAbbreviation'):
            self.unitsAbbreviation = attrs.get('unitsAbbreviation').value
        if attrs.get('unitsType'):
            self.unitsType = attrs.get('unitsType').value
            self.validate_UnitsTypeEnum(self.unitsType)    # validate type UnitsTypeEnum
        if attrs.get('timeZoneShiftApplied'):
            if attrs.get('timeZoneShiftApplied').value in ('true', '1'):
                self.timeZoneShiftApplied = True
            elif attrs.get('timeZoneShiftApplied').value in ('false', '0'):
                self.timeZoneShiftApplied = False
            else:
                raise ValueError('Bad boolean attribute (timeZoneShiftApplied)')
        if attrs.get('unitsAreConverted'):
            if attrs.get('unitsAreConverted').value in ('true', '1'):
                self.unitsAreConverted = True
            elif attrs.get('unitsAreConverted').value in ('false', '0'):
                self.unitsAreConverted = False
            else:
                raise ValueError('Bad boolean attribute (unitsAreConverted)')
        if attrs.get('unitsCode'):
            self.unitsCode = attrs.get('unitsCode').value
            self.unitsCode = ' '.join(self.unitsCode.split())
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'value':
            obj_ = ValueSingleVariable.factory()
            obj_.build(child_)
            self.value.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'qualifier':
            obj_ = qualifier.factory()
            obj_.build(child_)
            self.qualifier.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'qualityControlLevel':
            obj_ = qualityControlLevel.factory()
            obj_.build(child_)
            self.qualityControlLevel.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'method':
            obj_ = MethodType.factory()
            obj_.build(child_)
            self.method.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'source':
            obj_ = SourceType.factory()
            obj_.build(child_)
            self.source.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'offset':
            obj_ = OffsetType.factory()
            obj_.build(child_)
            self.offset.append(obj_)
# end class TsValuesSingleVariableType


class VariableInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, metadataDateTime=None, oid=None, variableCode=None, variableName=None, variableDescription=None, valueType=None, dataType=None, generalCategory=None, sampleMedium=None, units=None, options=None, note=None, related=None, extension=None, NoDataValue=None, timeSupport=None):
        self.metadataDateTime = _cast(None, metadataDateTime)
        self.oid = _cast(None, oid)
        if variableCode is None:
            self.variableCode = []
        else:
            self.variableCode = variableCode
        self.variableName = variableName
        self.variableDescription = variableDescription
        self.valueType = valueType
        self.dataType = dataType
        self.generalCategory = generalCategory
        self.sampleMedium = sampleMedium
        self.units = units
        self.options = options
        if note is None:
            self.note = []
        else:
            self.note = note
        self.related = related
        self.extension = extension
        self.NoDataValue = NoDataValue
        self.timeSupport = timeSupport
    def factory(*args_, **kwargs_):
        if VariableInfoType.subclass:
            return VariableInfoType.subclass(*args_, **kwargs_)
        else:
            return VariableInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_variableCode(self): return self.variableCode
    def set_variableCode(self, variableCode): self.variableCode = variableCode
    def add_variableCode(self, value): self.variableCode.append(value)
    def insert_variableCode(self, index, value): self.variableCode[index] = value
    def get_variableName(self): return self.variableName
    def set_variableName(self, variableName): self.variableName = variableName
    def get_variableDescription(self): return self.variableDescription
    def set_variableDescription(self, variableDescription): self.variableDescription = variableDescription
    def get_valueType(self): return self.valueType
    def set_valueType(self, valueType): self.valueType = valueType
    def validate_valueType(self, value):
        # validate type valueType
        pass
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def validate_dataType(self, value):
        # validate type dataType
        pass
    def get_generalCategory(self): return self.generalCategory
    def set_generalCategory(self, generalCategory): self.generalCategory = generalCategory
    def validate_generalCategory(self, value):
        # validate type generalCategory
        pass
    def get_sampleMedium(self): return self.sampleMedium
    def set_sampleMedium(self, sampleMedium): self.sampleMedium = sampleMedium
    def validate_sampleMedium(self, value):
        # validate type sampleMedium
        pass
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_options(self): return self.options
    def set_options(self, options): self.options = options
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def get_related(self): return self.related
    def set_related(self, related): self.related = related
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_NoDataValue(self): return self.NoDataValue
    def set_NoDataValue(self, NoDataValue): self.NoDataValue = NoDataValue
    def get_timeSupport(self): return self.timeSupport
    def set_timeSupport(self, timeSupport): self.timeSupport = timeSupport
    def get_metadataDateTime(self): return self.metadataDateTime
    def set_metadataDateTime(self, metadataDateTime): self.metadataDateTime = metadataDateTime
    def get_oid(self): return self.oid
    def set_oid(self, oid): self.oid = oid
    def export(self, outfile, level, namespace_='', name_='VariableInfoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='VariableInfoType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='VariableInfoType'):
        if self.metadataDateTime is not None:
            outfile.write(' metadataDateTime=%s' % (self.format_string(quote_attrib(self.metadataDateTime).encode(ExternalEncoding), input_name='metadataDateTime'), ))
        if self.oid is not None:
            outfile.write(' oid=%s' % (self.format_string(quote_attrib(self.oid).encode(ExternalEncoding), input_name='oid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VariableInfoType'):
        for variableCode_ in self.variableCode:
            variableCode_.export(outfile, level, namespace_, name_='variableCode')
        if self.variableName is not None:
            showIndent(outfile, level)
            outfile.write('<%svariableName>%s</%svariableName>\n' % (namespace_, self.format_string(quote_xml(self.variableName).encode(ExternalEncoding), input_name='variableName'), namespace_))
        if self.variableDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%svariableDescription>%s</%svariableDescription>\n' % (namespace_, self.format_string(quote_xml(self.variableDescription).encode(ExternalEncoding), input_name='variableDescription'), namespace_))
        if self.valueType is not None:
            showIndent(outfile, level)
            outfile.write('<%svalueType>%s</%svalueType>\n' % (namespace_, self.format_string(quote_xml(self.valueType).encode(ExternalEncoding), input_name='valueType'), namespace_))
        if self.dataType is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataType>%s</%sdataType>\n' % (namespace_, self.format_string(quote_xml(self.dataType).encode(ExternalEncoding), input_name='dataType'), namespace_))
        if self.generalCategory is not None:
            showIndent(outfile, level)
            outfile.write('<%sgeneralCategory>%s</%sgeneralCategory>\n' % (namespace_, self.format_string(quote_xml(self.generalCategory).encode(ExternalEncoding), input_name='generalCategory'), namespace_))
        if self.sampleMedium is not None:
            showIndent(outfile, level)
            outfile.write('<%ssampleMedium>%s</%ssampleMedium>\n' % (namespace_, self.format_string(quote_xml(self.sampleMedium).encode(ExternalEncoding), input_name='sampleMedium'), namespace_))
        if self.units:
            self.units.export(outfile, level, namespace_, name_='units')
        if self.options:
            self.options.export(outfile, level, namespace_, name_='options')
        for note_ in self.note:
            note_.export(outfile, level, namespace_, name_='note')
        if self.related:
            self.related.export(outfile, level, namespace_, name_='related')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('<%sextension>%s</%sextension>\n' % (namespace_, self.format_string(quote_xml(self.extension).encode(ExternalEncoding), input_name='extension'), namespace_))
        if self.NoDataValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sNoDataValue>%s</%sNoDataValue>\n' % (namespace_, self.format_string(quote_xml(self.NoDataValue).encode(ExternalEncoding), input_name='NoDataValue'), namespace_))
        if self.timeSupport:
            self.timeSupport.export(outfile, level, namespace_, name_='timeSupport')
    def hasContent_(self):
        if (
            self.variableCode or
            self.variableName is not None or
            self.variableDescription is not None or
            self.valueType is not None or
            self.dataType is not None or
            self.generalCategory is not None or
            self.sampleMedium is not None or
            self.units is not None or
            self.options is not None or
            self.note or
            self.related is not None or
            self.extension is not None or
            self.NoDataValue is not None or
            self.timeSupport is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariableInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.metadataDateTime is not None:
            showIndent(outfile, level)
            outfile.write('metadataDateTime = "%s",\n' % (self.metadataDateTime,))
        if self.oid is not None:
            showIndent(outfile, level)
            outfile.write('oid = "%s",\n' % (self.oid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('variableCode=[\n')
        level += 1
        for variableCode_ in self.variableCode:
            showIndent(outfile, level)
            outfile.write('model_.variableCode(\n')
            variableCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.variableName is not None:
            showIndent(outfile, level)
            outfile.write('variableName=%s,\n' % quote_python(self.variableName).encode(ExternalEncoding))
        if self.variableDescription is not None:
            showIndent(outfile, level)
            outfile.write('variableDescription=%s,\n' % quote_python(self.variableDescription).encode(ExternalEncoding))
        if self.valueType is not None:
            showIndent(outfile, level)
            outfile.write('valueType=%s,\n' % quote_python(self.valueType).encode(ExternalEncoding))
        if self.dataType is not None:
            showIndent(outfile, level)
            outfile.write('dataType=%s,\n' % quote_python(self.dataType).encode(ExternalEncoding))
        if self.generalCategory is not None:
            showIndent(outfile, level)
            outfile.write('generalCategory=%s,\n' % quote_python(self.generalCategory).encode(ExternalEncoding))
        if self.sampleMedium is not None:
            showIndent(outfile, level)
            outfile.write('sampleMedium=%s,\n' % quote_python(self.sampleMedium).encode(ExternalEncoding))
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('units=model_.units(\n')
            self.units.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.options is not None:
            showIndent(outfile, level)
            outfile.write('options=model_.options(\n')
            self.options.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('model_.NoteType(\n')
            note_.exportLiteral(outfile, level, name_='NoteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.related is not None:
            showIndent(outfile, level)
            outfile.write('related=model_.related(\n')
            self.related.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('extension=%s,\n' % quote_python(self.extension).encode(ExternalEncoding))
        if self.NoDataValue is not None:
            showIndent(outfile, level)
            outfile.write('NoDataValue=%s,\n' % quote_python(self.NoDataValue).encode(ExternalEncoding))
        if self.timeSupport is not None:
            showIndent(outfile, level)
            outfile.write('timeSupport=model_.timeSupport(\n')
            self.timeSupport.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('metadataDateTime'):
            self.metadataDateTime = attrs.get('metadataDateTime').value
        if attrs.get('oid'):
            self.oid = attrs.get('oid').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'variableCode':
            obj_ = variableCode.factory()
            obj_.build(child_)
            self.variableCode.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'variableName':
            variableName_ = ''
            for text__content_ in child_.childNodes:
                variableName_ += text__content_.nodeValue
            self.variableName = variableName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'variableDescription':
            variableDescription_ = ''
            for text__content_ in child_.childNodes:
                variableDescription_ += text__content_.nodeValue
            self.variableDescription = variableDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'valueType':
            valueType_ = ''
            for text__content_ in child_.childNodes:
                valueType_ += text__content_.nodeValue
            self.valueType = valueType_
            self.validate_valueType(self.valueType)    # validate type valueType
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataType':
            dataType_ = ''
            for text__content_ in child_.childNodes:
                dataType_ += text__content_.nodeValue
            self.dataType = dataType_
            self.validate_dataType(self.dataType)    # validate type dataType
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'generalCategory':
            generalCategory_ = ''
            for text__content_ in child_.childNodes:
                generalCategory_ += text__content_.nodeValue
            self.generalCategory = generalCategory_
            self.validate_generalCategory(self.generalCategory)    # validate type generalCategory
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sampleMedium':
            sampleMedium_ = ''
            for text__content_ in child_.childNodes:
                sampleMedium_ += text__content_.nodeValue
            self.sampleMedium = sampleMedium_
            self.validate_sampleMedium(self.sampleMedium)    # validate type sampleMedium
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'units':
            obj_ = units.factory()
            obj_.build(child_)
            self.set_units(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'options':
            obj_ = options.factory()
            obj_.build(child_)
            self.set_options(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'note':
            obj_ = NoteType.factory()
            obj_.build(child_)
            self.note.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'related':
            obj_ = related.factory()
            obj_.build(child_)
            self.set_related(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extension':
            extension_ = ''
            for text__content_ in child_.childNodes:
                extension_ += text__content_.nodeValue
            self.extension = extension_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'NoDataValue':
            NoDataValue_ = ''
            for text__content_ in child_.childNodes:
                NoDataValue_ += text__content_.nodeValue
            self.NoDataValue = NoDataValue_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timeSupport':
            obj_ = timeSupport.factory()
            obj_.build(child_)
            self.set_timeSupport(obj_)
# end class VariableInfoType


class related(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parentID=None, relatedID=None):
        self.parentID = parentID
        self.relatedID = relatedID
    def factory(*args_, **kwargs_):
        if related.subclass:
            return related.subclass(*args_, **kwargs_)
        else:
            return related(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parentID(self): return self.parentID
    def set_parentID(self, parentID): self.parentID = parentID
    def get_relatedID(self): return self.relatedID
    def set_relatedID(self, relatedID): self.relatedID = relatedID
    def export(self, outfile, level, namespace_='', name_='related', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='related')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='related'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='related'):
        if self.parentID is not None:
            showIndent(outfile, level)
            outfile.write('<%sparentID>%s</%sparentID>\n' % (namespace_, self.format_string(quote_xml(self.parentID).encode(ExternalEncoding), input_name='parentID'), namespace_))
        if self.relatedID is not None:
            showIndent(outfile, level)
            outfile.write('<%srelatedID>%s</%srelatedID>\n' % (namespace_, self.format_string(quote_xml(self.relatedID).encode(ExternalEncoding), input_name='relatedID'), namespace_))
    def hasContent_(self):
        if (
            self.parentID is not None or
            self.relatedID is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='related'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.parentID is not None:
            showIndent(outfile, level)
            outfile.write('parentID=%s,\n' % quote_python(self.parentID).encode(ExternalEncoding))
        if self.relatedID is not None:
            showIndent(outfile, level)
            outfile.write('relatedID=%s,\n' % quote_python(self.relatedID).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'parentID':
            obj_ = xsi_string.factory()
            obj_.build(child_)
            self.set_parentID(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'relatedID':
            obj_ = xsi_string.factory()
            obj_.build(child_)
            self.set_relatedID(obj_)
# end class related


class parentID(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None, network=None, vocabulary=None, valueOf_=None):
        self.default = _cast(bool, default)
        self.network = _cast(None, network)
        self.vocabulary = _cast(None, vocabulary)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if parentID.subclass:
            return parentID.subclass(*args_, **kwargs_)
        else:
            return parentID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='parentID', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='parentID')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='parentID'):
        if self.default is not None:
            outfile.write(' default="%s"' % self.format_boolean(str_lower(str(self.default)), input_name='default'))
        if self.network is not None:
            outfile.write(' network=%s' % (self.format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
        if self.vocabulary is not None:
            outfile.write(' vocabulary=%s' % (self.format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='parentID'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='parentID'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.default is not None:
            showIndent(outfile, level)
            outfile.write('default = %s,\n' % (self.default,))
        if self.network is not None:
            showIndent(outfile, level)
            outfile.write('network = "%s",\n' % (self.network,))
        if self.vocabulary is not None:
            showIndent(outfile, level)
            outfile.write('vocabulary = "%s",\n' % (self.vocabulary,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('default'):
            if attrs.get('default').value in ('true', '1'):
                self.default = True
            elif attrs.get('default').value in ('false', '0'):
                self.default = False
            else:
                raise ValueError('Bad boolean attribute (default)')
        if attrs.get('network'):
            self.network = attrs.get('network').value
        if attrs.get('vocabulary'):
            self.vocabulary = attrs.get('vocabulary').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class parentID


class relatedID(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None, network=None, vocabulary=None, valueOf_=None):
        self.default = _cast(bool, default)
        self.network = _cast(None, network)
        self.vocabulary = _cast(None, vocabulary)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if relatedID.subclass:
            return relatedID.subclass(*args_, **kwargs_)
        else:
            return relatedID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='relatedID', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='relatedID')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='relatedID'):
        if self.default is not None:
            outfile.write(' default="%s"' % self.format_boolean(str_lower(str(self.default)), input_name='default'))
        if self.network is not None:
            outfile.write(' network=%s' % (self.format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
        if self.vocabulary is not None:
            outfile.write(' vocabulary=%s' % (self.format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='relatedID'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='relatedID'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.default is not None:
            showIndent(outfile, level)
            outfile.write('default = %s,\n' % (self.default,))
        if self.network is not None:
            showIndent(outfile, level)
            outfile.write('network = "%s",\n' % (self.network,))
        if self.vocabulary is not None:
            showIndent(outfile, level)
            outfile.write('vocabulary = "%s",\n' % (self.vocabulary,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('default'):
            if attrs.get('default').value in ('true', '1'):
                self.default = True
            elif attrs.get('default').value in ('false', '0'):
                self.default = False
            else:
                raise ValueError('Bad boolean attribute (default)')
        if attrs.get('network'):
            self.network = attrs.get('network').value
        if attrs.get('vocabulary'):
            self.vocabulary = attrs.get('vocabulary').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class relatedID


class timeSupport(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, isRegular=None, unit=None, timeInterval=None):
        self.isRegular = _cast(bool, isRegular)
        self.unit = unit
        self.timeInterval = timeInterval
    def factory(*args_, **kwargs_):
        if timeSupport.subclass:
            return timeSupport.subclass(*args_, **kwargs_)
        else:
            return timeSupport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_timeInterval(self): return self.timeInterval
    def set_timeInterval(self, timeInterval): self.timeInterval = timeInterval
    def get_isRegular(self): return self.isRegular
    def set_isRegular(self, isRegular): self.isRegular = isRegular
    def export(self, outfile, level, namespace_='', name_='timeSupport', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='timeSupport')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='timeSupport'):
        if self.isRegular is not None:
            outfile.write(' isRegular="%s"' % self.format_boolean(str_lower(str(self.isRegular)), input_name='isRegular'))
    def exportChildren(self, outfile, level, namespace_='', name_='timeSupport'):
        if self.unit:
            self.unit.export(outfile, level, namespace_, name_='unit')
        if self.timeInterval is not None:
            showIndent(outfile, level)
            outfile.write('<%stimeInterval>%s</%stimeInterval>\n' % (namespace_, self.format_string(quote_xml(self.timeInterval).encode(ExternalEncoding), input_name='timeInterval'), namespace_))
    def hasContent_(self):
        if (
            self.unit is not None or
            self.timeInterval is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='timeSupport'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.isRegular is not None:
            showIndent(outfile, level)
            outfile.write('isRegular = %s,\n' % (self.isRegular,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.unit is not None:
            showIndent(outfile, level)
            outfile.write('unit=model_.UnitsType(\n')
            self.unit.exportLiteral(outfile, level, name_='unit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timeInterval is not None:
            showIndent(outfile, level)
            outfile.write('timeInterval=%s,\n' % quote_python(self.timeInterval).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('isRegular'):
            if attrs.get('isRegular').value in ('true', '1'):
                self.isRegular = True
            elif attrs.get('isRegular').value in ('false', '0'):
                self.isRegular = False
            else:
                raise ValueError('Bad boolean attribute (isRegular)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'unit':
            obj_ = UnitsType.factory()
            obj_.build(child_)
            self.set_unit(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timeInterval':
            timeInterval_ = ''
            for text__content_ in child_.childNodes:
                timeInterval_ += text__content_.nodeValue
            self.timeInterval = timeInterval_
# end class timeSupport


class QueryInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, creationTime=None, queryURL=None, querySQL=None, criteria=None, note=None, extension=None):
        self.creationTime = creationTime
        self.queryURL = queryURL
        self.querySQL = querySQL
        self.criteria = criteria
        if note is None:
            self.note = []
        else:
            self.note = note
        self.extension = extension
    def factory(*args_, **kwargs_):
        if QueryInfoType.subclass:
            return QueryInfoType.subclass(*args_, **kwargs_)
        else:
            return QueryInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creationTime(self): return self.creationTime
    def set_creationTime(self, creationTime): self.creationTime = creationTime
    def get_queryURL(self): return self.queryURL
    def set_queryURL(self, queryURL): self.queryURL = queryURL
    def get_querySQL(self): return self.querySQL
    def set_querySQL(self, querySQL): self.querySQL = querySQL
    def get_criteria(self): return self.criteria
    def set_criteria(self, criteria): self.criteria = criteria
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def export(self, outfile, level, namespace_='', name_='QueryInfoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='QueryInfoType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='QueryInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QueryInfoType'):
        if self.creationTime is not None:
            showIndent(outfile, level)
            outfile.write('<%screationTime>%s</%screationTime>\n' % (namespace_, self.format_string(quote_xml(self.creationTime).encode(ExternalEncoding), input_name='creationTime'), namespace_))
        if self.queryURL is not None:
            showIndent(outfile, level)
            outfile.write('<%squeryURL>%s</%squeryURL>\n' % (namespace_, self.format_string(quote_xml(self.queryURL).encode(ExternalEncoding), input_name='queryURL'), namespace_))
        if self.querySQL is not None:
            showIndent(outfile, level)
            outfile.write('<%squerySQL>%s</%squerySQL>\n' % (namespace_, self.format_string(quote_xml(self.querySQL).encode(ExternalEncoding), input_name='querySQL'), namespace_))
        if self.criteria:
            self.criteria.export(outfile, level, namespace_, name_='criteria')
        for note_ in self.note:
            note_.export(outfile, level, namespace_, name_='note')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('<%sextension>%s</%sextension>\n' % (namespace_, self.format_string(quote_xml(self.extension).encode(ExternalEncoding), input_name='extension'), namespace_))
    def hasContent_(self):
        if (
            self.creationTime is not None or
            self.queryURL is not None or
            self.querySQL is not None or
            self.criteria is not None or
            self.note or
            self.extension is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QueryInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.creationTime is not None:
            showIndent(outfile, level)
            outfile.write('creationTime=%s,\n' % quote_python(self.creationTime).encode(ExternalEncoding))
        if self.queryURL is not None:
            showIndent(outfile, level)
            outfile.write('queryURL=%s,\n' % quote_python(self.queryURL).encode(ExternalEncoding))
        if self.querySQL is not None:
            showIndent(outfile, level)
            outfile.write('querySQL=%s,\n' % quote_python(self.querySQL).encode(ExternalEncoding))
        if self.criteria is not None:
            showIndent(outfile, level)
            outfile.write('criteria=model_.criteria(\n')
            self.criteria.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('model_.NoteType(\n')
            note_.exportLiteral(outfile, level, name_='NoteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('extension=%s,\n' % quote_python(self.extension).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'creationTime':
            creationTime_ = ''
            for text__content_ in child_.childNodes:
                creationTime_ += text__content_.nodeValue
            self.creationTime = creationTime_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'queryURL':
            queryURL_ = ''
            for text__content_ in child_.childNodes:
                queryURL_ += text__content_.nodeValue
            self.queryURL = queryURL_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'querySQL':
            querySQL_ = ''
            for text__content_ in child_.childNodes:
                querySQL_ += text__content_.nodeValue
            self.querySQL = querySQL_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'criteria':
            obj_ = criteria.factory()
            obj_.build(child_)
            self.set_criteria(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'note':
            obj_ = NoteType.factory()
            obj_.build(child_)
            self.note.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extension':
            extension_ = ''
            for text__content_ in child_.childNodes:
                extension_ += text__content_.nodeValue
            self.extension = extension_
# end class QueryInfoType


class criteria(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, locationParam=None, variableParam=None, timeParam=None):
        self.locationParam = locationParam
        self.variableParam = variableParam
        self.timeParam = timeParam
    def factory(*args_, **kwargs_):
        if criteria.subclass:
            return criteria.subclass(*args_, **kwargs_)
        else:
            return criteria(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_locationParam(self): return self.locationParam
    def set_locationParam(self, locationParam): self.locationParam = locationParam
    def get_variableParam(self): return self.variableParam
    def set_variableParam(self, variableParam): self.variableParam = variableParam
    def get_timeParam(self): return self.timeParam
    def set_timeParam(self, timeParam): self.timeParam = timeParam
    def export(self, outfile, level, namespace_='', name_='criteria', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='criteria')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='criteria'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='criteria'):
        if self.locationParam is not None:
            showIndent(outfile, level)
            outfile.write('<%slocationParam>%s</%slocationParam>\n' % (namespace_, self.format_string(quote_xml(self.locationParam).encode(ExternalEncoding), input_name='locationParam'), namespace_))
        if self.variableParam is not None:
            showIndent(outfile, level)
            outfile.write('<%svariableParam>%s</%svariableParam>\n' % (namespace_, self.format_string(quote_xml(self.variableParam).encode(ExternalEncoding), input_name='variableParam'), namespace_))
        if self.timeParam:
            self.timeParam.export(outfile, level, namespace_, name_='timeParam')
    def hasContent_(self):
        if (
            self.locationParam is not None or
            self.variableParam is not None or
            self.timeParam is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='criteria'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.locationParam is not None:
            showIndent(outfile, level)
            outfile.write('locationParam=%s,\n' % quote_python(self.locationParam).encode(ExternalEncoding))
        if self.variableParam is not None:
            showIndent(outfile, level)
            outfile.write('variableParam=%s,\n' % quote_python(self.variableParam).encode(ExternalEncoding))
        if self.timeParam is not None:
            showIndent(outfile, level)
            outfile.write('timeParam=model_.timeParam(\n')
            self.timeParam.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'locationParam':
            locationParam_ = ''
            for text__content_ in child_.childNodes:
                locationParam_ += text__content_.nodeValue
            self.locationParam = locationParam_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'variableParam':
            variableParam_ = ''
            for text__content_ in child_.childNodes:
                variableParam_ += text__content_.nodeValue
            self.variableParam = variableParam_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timeParam':
            obj_ = timeParam.factory()
            obj_.build(child_)
            self.set_timeParam(obj_)
# end class criteria


class timeParam(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, beginDateTime=None, endDateTime=None):
        self.beginDateTime = beginDateTime
        self.endDateTime = endDateTime
    def factory(*args_, **kwargs_):
        if timeParam.subclass:
            return timeParam.subclass(*args_, **kwargs_)
        else:
            return timeParam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_beginDateTime(self): return self.beginDateTime
    def set_beginDateTime(self, beginDateTime): self.beginDateTime = beginDateTime
    def get_endDateTime(self): return self.endDateTime
    def set_endDateTime(self, endDateTime): self.endDateTime = endDateTime
    def export(self, outfile, level, namespace_='', name_='timeParam', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='timeParam')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='timeParam'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='timeParam'):
        if self.beginDateTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sbeginDateTime>%s</%sbeginDateTime>\n' % (namespace_, self.format_string(quote_xml(self.beginDateTime).encode(ExternalEncoding), input_name='beginDateTime'), namespace_))
        if self.endDateTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sendDateTime>%s</%sendDateTime>\n' % (namespace_, self.format_string(quote_xml(self.endDateTime).encode(ExternalEncoding), input_name='endDateTime'), namespace_))
    def hasContent_(self):
        if (
            self.beginDateTime is not None or
            self.endDateTime is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='timeParam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.beginDateTime is not None:
            showIndent(outfile, level)
            outfile.write('beginDateTime=%s,\n' % quote_python(self.beginDateTime).encode(ExternalEncoding))
        if self.endDateTime is not None:
            showIndent(outfile, level)
            outfile.write('endDateTime=%s,\n' % quote_python(self.endDateTime).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'beginDateTime':
            beginDateTime_ = ''
            for text__content_ in child_.childNodes:
                beginDateTime_ += text__content_.nodeValue
            self.beginDateTime = beginDateTime_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'endDateTime':
            endDateTime_ = ''
            for text__content_ in child_.childNodes:
                endDateTime_ += text__content_.nodeValue
            self.endDateTime = endDateTime_
# end class timeParam


class variables(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variable=None):
        if variable is None:
            self.variable = []
        else:
            self.variable = variable
    def factory(*args_, **kwargs_):
        if variables.subclass:
            return variables.subclass(*args_, **kwargs_)
        else:
            return variables(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_variable(self): return self.variable
    def set_variable(self, variable): self.variable = variable
    def add_variable(self, value): self.variable.append(value)
    def insert_variable(self, index, value): self.variable[index] = value
    def export(self, outfile, level, namespace_='', name_='variables', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='variables')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='variables'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='variables'):
        for variable_ in self.variable:
            variable_.export(outfile, level, namespace_, name_='variable')
    def hasContent_(self):
        if (
            self.variable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='variables'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('variable=[\n')
        level += 1
        for variable_ in self.variable:
            showIndent(outfile, level)
            outfile.write('model_.VariableInfoType(\n')
            variable_.exportLiteral(outfile, level, name_='VariableInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'variable':
            obj_ = VariableInfoType.factory()
            obj_.build(child_)
            self.variable.append(obj_)
# end class variables


class timeZoneInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, siteUsesDaylightSavingsTime=False, defaultTimeZone=None, daylightSavingsTimeZone=None):
        self.siteUsesDaylightSavingsTime = _cast(bool, siteUsesDaylightSavingsTime)
        self.defaultTimeZone = defaultTimeZone
        self.daylightSavingsTimeZone = daylightSavingsTimeZone
    def factory(*args_, **kwargs_):
        if timeZoneInfo.subclass:
            return timeZoneInfo.subclass(*args_, **kwargs_)
        else:
            return timeZoneInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_defaultTimeZone(self): return self.defaultTimeZone
    def set_defaultTimeZone(self, defaultTimeZone): self.defaultTimeZone = defaultTimeZone
    def get_daylightSavingsTimeZone(self): return self.daylightSavingsTimeZone
    def set_daylightSavingsTimeZone(self, daylightSavingsTimeZone): self.daylightSavingsTimeZone = daylightSavingsTimeZone
    def get_siteUsesDaylightSavingsTime(self): return self.siteUsesDaylightSavingsTime
    def set_siteUsesDaylightSavingsTime(self, siteUsesDaylightSavingsTime): self.siteUsesDaylightSavingsTime = siteUsesDaylightSavingsTime
    def export(self, outfile, level, namespace_='', name_='timeZoneInfo', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='timeZoneInfo')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='timeZoneInfo'):
        if self.siteUsesDaylightSavingsTime is not None:
            outfile.write(' siteUsesDaylightSavingsTime="%s"' % self.format_boolean(str_lower(str(self.siteUsesDaylightSavingsTime)), input_name='siteUsesDaylightSavingsTime'))
    def exportChildren(self, outfile, level, namespace_='', name_='timeZoneInfo'):
        if self.defaultTimeZone is not None:
            showIndent(outfile, level)
            outfile.write('<%sdefaultTimeZone>%s</%sdefaultTimeZone>\n' % (namespace_, self.format_string(quote_xml(self.defaultTimeZone).encode(ExternalEncoding), input_name='defaultTimeZone'), namespace_))
        if self.daylightSavingsTimeZone is not None:
            showIndent(outfile, level)
            outfile.write('<%sdaylightSavingsTimeZone>%s</%sdaylightSavingsTimeZone>\n' % (namespace_, self.format_string(quote_xml(self.daylightSavingsTimeZone).encode(ExternalEncoding), input_name='daylightSavingsTimeZone'), namespace_))
    def hasContent_(self):
        if (
            self.defaultTimeZone is not None or
            self.daylightSavingsTimeZone is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='timeZoneInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.siteUsesDaylightSavingsTime is not None:
            showIndent(outfile, level)
            outfile.write('siteUsesDaylightSavingsTime = %s,\n' % (self.siteUsesDaylightSavingsTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.defaultTimeZone is not None:
            showIndent(outfile, level)
            outfile.write('defaultTimeZone=%s,\n' % quote_python(self.defaultTimeZone).encode(ExternalEncoding))
        if self.daylightSavingsTimeZone is not None:
            showIndent(outfile, level)
            outfile.write('daylightSavingsTimeZone=%s,\n' % quote_python(self.daylightSavingsTimeZone).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('siteUsesDaylightSavingsTime'):
            if attrs.get('siteUsesDaylightSavingsTime').value in ('true', '1'):
                self.siteUsesDaylightSavingsTime = True
            elif attrs.get('siteUsesDaylightSavingsTime').value in ('false', '0'):
                self.siteUsesDaylightSavingsTime = False
            else:
                raise ValueError('Bad boolean attribute (siteUsesDaylightSavingsTime)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'defaultTimeZone':
            obj_ = xsi_string.factory()
            obj_.build(child_)
            self.set_defaultTimeZone(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'daylightSavingsTimeZone':
            obj_ = xsi_string.factory()
            obj_.build(child_)
            self.set_daylightSavingsTimeZone(obj_)
# end class timeZoneInfo


class defaultTimeZone(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ZoneOffset=None, ZoneAbbreviation=None, valueOf_=None):
        self.ZoneOffset = _cast(None, ZoneOffset)
        self.ZoneAbbreviation = _cast(None, ZoneAbbreviation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if defaultTimeZone.subclass:
            return defaultTimeZone.subclass(*args_, **kwargs_)
        else:
            return defaultTimeZone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZoneOffset(self): return self.ZoneOffset
    def set_ZoneOffset(self, ZoneOffset): self.ZoneOffset = ZoneOffset
    def get_ZoneAbbreviation(self): return self.ZoneAbbreviation
    def set_ZoneAbbreviation(self, ZoneAbbreviation): self.ZoneAbbreviation = ZoneAbbreviation
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='defaultTimeZone', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='defaultTimeZone')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='defaultTimeZone'):
        outfile.write(' ZoneOffset=%s' % (self.format_string(quote_attrib(self.ZoneOffset).encode(ExternalEncoding), input_name='ZoneOffset'), ))
        if self.ZoneAbbreviation is not None:
            outfile.write(' ZoneAbbreviation=%s' % (self.format_string(quote_attrib(self.ZoneAbbreviation).encode(ExternalEncoding), input_name='ZoneAbbreviation'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='defaultTimeZone'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='defaultTimeZone'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.ZoneOffset is not None:
            showIndent(outfile, level)
            outfile.write('ZoneOffset = "%s",\n' % (self.ZoneOffset,))
        if self.ZoneAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('ZoneAbbreviation = "%s",\n' % (self.ZoneAbbreviation,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('ZoneOffset'):
            self.ZoneOffset = attrs.get('ZoneOffset').value
        if attrs.get('ZoneAbbreviation'):
            self.ZoneAbbreviation = attrs.get('ZoneAbbreviation').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class defaultTimeZone


class daylightSavingsTimeZone(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ZoneOffset=None, ZoneAbbreviation=None, valueOf_=None):
        self.ZoneOffset = _cast(None, ZoneOffset)
        self.ZoneAbbreviation = _cast(None, ZoneAbbreviation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if daylightSavingsTimeZone.subclass:
            return daylightSavingsTimeZone.subclass(*args_, **kwargs_)
        else:
            return daylightSavingsTimeZone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZoneOffset(self): return self.ZoneOffset
    def set_ZoneOffset(self, ZoneOffset): self.ZoneOffset = ZoneOffset
    def get_ZoneAbbreviation(self): return self.ZoneAbbreviation
    def set_ZoneAbbreviation(self, ZoneAbbreviation): self.ZoneAbbreviation = ZoneAbbreviation
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='daylightSavingsTimeZone', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='daylightSavingsTimeZone')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='daylightSavingsTimeZone'):
        outfile.write(' ZoneOffset=%s' % (self.format_string(quote_attrib(self.ZoneOffset).encode(ExternalEncoding), input_name='ZoneOffset'), ))
        if self.ZoneAbbreviation is not None:
            outfile.write(' ZoneAbbreviation=%s' % (self.format_string(quote_attrib(self.ZoneAbbreviation).encode(ExternalEncoding), input_name='ZoneAbbreviation'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='daylightSavingsTimeZone'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='daylightSavingsTimeZone'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.ZoneOffset is not None:
            showIndent(outfile, level)
            outfile.write('ZoneOffset = "%s",\n' % (self.ZoneOffset,))
        if self.ZoneAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('ZoneAbbreviation = "%s",\n' % (self.ZoneAbbreviation,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('ZoneOffset'):
            self.ZoneOffset = attrs.get('ZoneOffset').value
        if attrs.get('ZoneAbbreviation'):
            self.ZoneAbbreviation = attrs.get('ZoneAbbreviation').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class daylightSavingsTimeZone


class optionGroup(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, option=None):
        if option is None:
            self.option = []
        else:
            self.option = option
    def factory(*args_, **kwargs_):
        if optionGroup.subclass:
            return optionGroup.subclass(*args_, **kwargs_)
        else:
            return optionGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_option(self): return self.option
    def set_option(self, option): self.option = option
    def add_option(self, value): self.option.append(value)
    def insert_option(self, index, value): self.option[index] = value
    def export(self, outfile, level, namespace_='', name_='optionGroup', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='optionGroup')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='optionGroup'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='optionGroup'):
        for option_ in self.option:
            option_.export(outfile, level, namespace_, name_='option')
    def hasContent_(self):
        if (
            self.option
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='optionGroup'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('option=[\n')
        level += 1
        for option_ in self.option:
            showIndent(outfile, level)
            outfile.write('model_.option(\n')
            option_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'option':
            obj_ = option.factory()
            obj_.build(child_)
            self.option.append(obj_)
# end class optionGroup


class DocumentationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, href=None, type_=None, show=None, valueOf_=None, mixedclass_=None, content_=None):
        self.title = _cast(None, title)
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.show = _cast(None, show)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DocumentationType.subclass:
            return DocumentationType.subclass(*args_, **kwargs_)
        else:
            return DocumentationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_DocumentationEnumTypes(self, value):
        # Validate type DocumentationEnumTypes, a restriction on xsi:token.
        pass
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='DocumentationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DocumentationType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='DocumentationType'):
        if self.title is not None:
            outfile.write(' title=%s' % (self.format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.href is not None:
            outfile.write(' href=%s' % (self.format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None:
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.show is not None:
            outfile.write(' show=%s' % (self.format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DocumentationType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DocumentationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.href is not None:
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.show is not None:
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('title'):
            self.title = attrs.get('title').value
        if attrs.get('href'):
            self.href = attrs.get('href').value
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
            self.validate_DocumentationEnumTypes(self.type_)    # validate type DocumentationEnumTypes
        if attrs.get('show'):
            self.show = attrs.get('show').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.nodeValue)
            self.content_.append(obj_)
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class DocumentationType


class options(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, option=None):
        if option is None:
            self.option = []
        else:
            self.option = option
    def factory(*args_, **kwargs_):
        if options.subclass:
            return options.subclass(*args_, **kwargs_)
        else:
            return options(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_option(self): return self.option
    def set_option(self, option): self.option = option
    def add_option(self, value): self.option.append(value)
    def insert_option(self, index, value): self.option[index] = value
    def export(self, outfile, level, namespace_='', name_='options', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='options')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='options'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='options'):
        for option_ in self.option:
            option_.export(outfile, level, namespace_, name_='option')
    def hasContent_(self):
        if (
            self.option
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='options'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('option=[\n')
        level += 1
        for option_ in self.option:
            showIndent(outfile, level)
            outfile.write('model_.option(\n')
            option_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'option':
            obj_ = option.factory()
            obj_.build(child_)
            self.option.append(obj_)
# end class options


class SourceInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SourceInfoType.subclass:
            return SourceInfoType.subclass(*args_, **kwargs_)
        else:
            return SourceInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='SourceInfoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SourceInfoType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='SourceInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SourceInfoType'):
        if not self.valueOf_ : return
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SourceInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class SourceInfoType


class DataSetInfoType(SourceInfoType):
    subclass = None
    superclass = SourceInfoType
    def __init__(self, dataSetIdentifier=None, timeZoneInfo=None, dataSetDescription=None, note=None, dataSetLocation=None, extension=None):
        SourceInfoType.__init__(self)
        self.dataSetIdentifier = dataSetIdentifier
        self.timeZoneInfo = timeZoneInfo
        self.dataSetDescription = dataSetDescription
        if note is None:
            self.note = []
        else:
            self.note = note
        self.dataSetLocation = dataSetLocation
        self.extension = extension
    def factory(*args_, **kwargs_):
        if DataSetInfoType.subclass:
            return DataSetInfoType.subclass(*args_, **kwargs_)
        else:
            return DataSetInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataSetIdentifier(self): return self.dataSetIdentifier
    def set_dataSetIdentifier(self, dataSetIdentifier): self.dataSetIdentifier = dataSetIdentifier
    def get_timeZoneInfo(self): return self.timeZoneInfo
    def set_timeZoneInfo(self, timeZoneInfo): self.timeZoneInfo = timeZoneInfo
    def get_dataSetDescription(self): return self.dataSetDescription
    def set_dataSetDescription(self, dataSetDescription): self.dataSetDescription = dataSetDescription
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def get_dataSetLocation(self): return self.dataSetLocation
    def set_dataSetLocation(self, dataSetLocation): self.dataSetLocation = dataSetLocation
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def export(self, outfile, level, namespace_='', name_='DataSetInfoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DataSetInfoType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="DataSetInfoType"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='DataSetInfoType'):
        SourceInfoType.exportAttributes(self, outfile, level, namespace_, name_='DataSetInfoType')
    def exportChildren(self, outfile, level, namespace_='', name_='DataSetInfoType'):
        SourceInfoType.exportChildren(self, outfile, level, namespace_, name_)
        if self.dataSetIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataSetIdentifier>%s</%sdataSetIdentifier>\n' % (namespace_, self.format_string(quote_xml(self.dataSetIdentifier).encode(ExternalEncoding), input_name='dataSetIdentifier'), namespace_))
        if self.timeZoneInfo:
            self.timeZoneInfo.export(outfile, level, namespace_, name_='timeZoneInfo')
        if self.dataSetDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataSetDescription>%s</%sdataSetDescription>\n' % (namespace_, self.format_string(quote_xml(self.dataSetDescription).encode(ExternalEncoding), input_name='dataSetDescription'), namespace_))
        for note_ in self.note:
            note_.export(outfile, level, namespace_, name_='note')
        if self.dataSetLocation:
            self.dataSetLocation.export(outfile, level, namespace_, name_='dataSetLocation')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('<%sextension>%s</%sextension>\n' % (namespace_, self.format_string(quote_xml(self.extension).encode(ExternalEncoding), input_name='extension'), namespace_))
    def hasContent_(self):
        if (
            self.dataSetIdentifier is not None or
            self.timeZoneInfo is not None or
            self.dataSetDescription is not None or
            self.note or
            self.dataSetLocation is not None or
            self.extension is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataSetInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        SourceInfoType.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        SourceInfoType.exportLiteralChildren(self, outfile, level, name_)
        if self.dataSetIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('dataSetIdentifier=%s,\n' % quote_python(self.dataSetIdentifier).encode(ExternalEncoding))
        if self.timeZoneInfo is not None:
            showIndent(outfile, level)
            outfile.write('timeZoneInfo=model_.timeZoneInfo(\n')
            self.timeZoneInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataSetDescription is not None:
            showIndent(outfile, level)
            outfile.write('dataSetDescription=%s,\n' % quote_python(self.dataSetDescription).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('model_.NoteType(\n')
            note_.exportLiteral(outfile, level, name_='NoteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.dataSetLocation is not None:
            showIndent(outfile, level)
            outfile.write('dataSetLocation=model_.GeogLocationType(\n')
            self.dataSetLocation.exportLiteral(outfile, level, name_='dataSetLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('extension=%s,\n' % quote_python(self.extension).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        SourceInfoType.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataSetIdentifier':
            dataSetIdentifier_ = ''
            for text__content_ in child_.childNodes:
                dataSetIdentifier_ += text__content_.nodeValue
            self.dataSetIdentifier = dataSetIdentifier_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timeZoneInfo':
            obj_ = timeZoneInfo.factory()
            obj_.build(child_)
            self.set_timeZoneInfo(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataSetDescription':
            dataSetDescription_ = ''
            for text__content_ in child_.childNodes:
                dataSetDescription_ += text__content_.nodeValue
            self.dataSetDescription = dataSetDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'note':
            obj_ = NoteType.factory()
            obj_.build(child_)
            self.note.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataSetLocation':
            obj_ = GeogLocationType.factory()
            obj_.build(child_)
            self.set_dataSetLocation(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extension':
            extension_ = ''
            for text__content_ in child_.childNodes:
                extension_ += text__content_.nodeValue
            self.extension = extension_
        SourceInfoType.buildChildren(self, child_, nodeName_)
# end class DataSetInfoType


class TimePeriodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TimePeriodType.subclass:
            return TimePeriodType.subclass(*args_, **kwargs_)
        else:
            return TimePeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='TimePeriodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TimePeriodType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='TimePeriodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TimePeriodType'):
        if not self.valueOf_:return
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimePeriodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class TimePeriodType


class TimeIntervalType(TimePeriodType):
    subclass = None
    superclass = TimePeriodType
    def __init__(self, beginDateTime=None, endDateTime=None):
        TimePeriodType.__init__(self)
        self.beginDateTime = beginDateTime
        self.endDateTime = endDateTime
    def factory(*args_, **kwargs_):
        if TimeIntervalType.subclass:
            return TimeIntervalType.subclass(*args_, **kwargs_)
        else:
            return TimeIntervalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_beginDateTime(self): return self.beginDateTime
    def set_beginDateTime(self, beginDateTime): self.beginDateTime = beginDateTime
    def get_endDateTime(self): return self.endDateTime
    def set_endDateTime(self, endDateTime): self.endDateTime = endDateTime
    def export(self, outfile, level, namespace_='', name_='TimeIntervalType', namespacedef_=''):
        #adjust the tag name for this xml element       
        if self.superclass.subclass == self.__class__:
            name_ = "variableTimeInterval"
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TimeIntervalType')
        #outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="TimeIntervalType"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='TimeIntervalType'):
        TimePeriodType.exportAttributes(self, outfile, level, namespace_, name_='TimeIntervalType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeIntervalType'):
        TimePeriodType.exportChildren(self, outfile, level, namespace_, name_)
        if self.beginDateTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sbeginDateTime>%s</%sbeginDateTime>\n' % (namespace_, self.format_string(quote_xml(self.beginDateTime).encode(ExternalEncoding), input_name='beginDateTime'), namespace_))
        if self.endDateTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sendDateTime>%s</%sendDateTime>\n' % (namespace_, self.format_string(quote_xml(self.endDateTime).encode(ExternalEncoding), input_name='endDateTime'), namespace_))
    def hasContent_(self):
        if (
            self.beginDateTime is not None or
            self.endDateTime is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeIntervalType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        TimePeriodType.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        TimePeriodType.exportLiteralChildren(self, outfile, level, name_)
        if self.beginDateTime is not None:
            showIndent(outfile, level)
            outfile.write('beginDateTime=%s,\n' % quote_python(self.beginDateTime).encode(ExternalEncoding))
        if self.endDateTime is not None:
            showIndent(outfile, level)
            outfile.write('endDateTime=%s,\n' % quote_python(self.endDateTime).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        TimePeriodType.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'beginDateTime':
            beginDateTime_ = ''
            for text__content_ in child_.childNodes:
                beginDateTime_ += text__content_.nodeValue
            self.beginDateTime = beginDateTime_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'endDateTime':
            endDateTime_ = ''
            for text__content_ in child_.childNodes:
                endDateTime_ += text__content_.nodeValue
            self.endDateTime = endDateTime_
        TimePeriodType.buildChildren(self, child_, nodeName_)
# end class TimeIntervalType


class TimeSingleType(TimePeriodType):
    subclass = None
    superclass = TimePeriodType
    def __init__(self, timeSingle=None, beginDateTime=None, endDateTime=None):
        TimePeriodType.__init__(self)
        self.timeSingle = timeSingle
        self.beginDateTime = beginDateTime
        self.endDateTime = endDateTime
    def factory(*args_, **kwargs_):
        if TimeSingleType.subclass:
            return TimeSingleType.subclass(*args_, **kwargs_)
        else:
            return TimeSingleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timeSingle(self): return self.timeSingle
    def set_timeSingle(self, timeSingle): self.timeSingle = timeSingle
    def get_beginDateTime(self): return self.beginDateTime
    def set_beginDateTime(self, beginDateTime): self.beginDateTime = beginDateTime
    def get_endDateTime(self): return self.endDateTime
    def set_endDateTime(self, endDateTime): self.endDateTime = endDateTime
    def export(self, outfile, level, namespace_='', name_='TimeSingleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TimeSingleType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="TimeSingleType"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='TimeSingleType'):
        TimePeriodType.exportAttributes(self, outfile, level, namespace_, name_='TimeSingleType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeSingleType'):
        TimePeriodType.exportChildren(self, outfile, level, namespace_, name_)
        if self.timeSingle is not None:
            showIndent(outfile, level)
            outfile.write('<%stimeSingle>%s</%stimeSingle>\n' % (namespace_, self.format_string(quote_xml(self.timeSingle).encode(ExternalEncoding), input_name='timeSingle'), namespace_))
        if self.beginDateTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sbeginDateTime>%s</%sbeginDateTime>\n' % (namespace_, self.format_string(quote_xml(self.beginDateTime).encode(ExternalEncoding), input_name='beginDateTime'), namespace_))
        if self.endDateTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sendDateTime>%s</%sendDateTime>\n' % (namespace_, self.format_string(quote_xml(self.endDateTime).encode(ExternalEncoding), input_name='endDateTime'), namespace_))
    def hasContent_(self):
        if (
            self.timeSingle is not None or
            self.beginDateTime is not None or
            self.endDateTime is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeSingleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        TimePeriodType.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        TimePeriodType.exportLiteralChildren(self, outfile, level, name_)
        if self.timeSingle is not None:
            showIndent(outfile, level)
            outfile.write('timeSingle=%s,\n' % quote_python(self.timeSingle).encode(ExternalEncoding))
        if self.beginDateTime is not None:
            showIndent(outfile, level)
            outfile.write('beginDateTime=%s,\n' % quote_python(self.beginDateTime).encode(ExternalEncoding))
        if self.endDateTime is not None:
            showIndent(outfile, level)
            outfile.write('endDateTime=%s,\n' % quote_python(self.endDateTime).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        TimePeriodType.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timeSingle':
            timeSingle_ = ''
            for text__content_ in child_.childNodes:
                timeSingle_ += text__content_.nodeValue
            self.timeSingle = timeSingle_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'beginDateTime':
            beginDateTime_ = ''
            for text__content_ in child_.childNodes:
                beginDateTime_ += text__content_.nodeValue
            self.beginDateTime = beginDateTime_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'endDateTime':
            endDateTime_ = ''
            for text__content_ in child_.childNodes:
                endDateTime_ += text__content_.nodeValue
            self.endDateTime = endDateTime_
        TimePeriodType.buildChildren(self, child_, nodeName_)
# end class TimeSingleType


class TimePeriodRealTimeType(TimePeriodType):
    subclass = None
    superclass = TimePeriodType
    def __init__(self, realTimeDataPeriod=None, beginDateTime=None, endDateTime=None):
        TimePeriodType.__init__(self)
        self.realTimeDataPeriod = realTimeDataPeriod
        self.beginDateTime = beginDateTime
        self.endDateTime = endDateTime
    def factory(*args_, **kwargs_):
        if TimePeriodRealTimeType.subclass:
            return TimePeriodRealTimeType.subclass(*args_, **kwargs_)
        else:
            return TimePeriodRealTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realTimeDataPeriod(self): return self.realTimeDataPeriod
    def set_realTimeDataPeriod(self, realTimeDataPeriod): self.realTimeDataPeriod = realTimeDataPeriod
    def get_beginDateTime(self): return self.beginDateTime
    def set_beginDateTime(self, beginDateTime): self.beginDateTime = beginDateTime
    def get_endDateTime(self): return self.endDateTime
    def set_endDateTime(self, endDateTime): self.endDateTime = endDateTime
    def export(self, outfile, level, namespace_='', name_='TimePeriodRealTimeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TimePeriodRealTimeType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="TimePeriodRealTimeType"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='TimePeriodRealTimeType'):
        TimePeriodType.exportAttributes(self, outfile, level, namespace_, name_='TimePeriodRealTimeType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimePeriodRealTimeType'):
        TimePeriodType.exportChildren(self, outfile, level, namespace_, name_)
        if self.realTimeDataPeriod is not None:
            showIndent(outfile, level)
            outfile.write('<%srealTimeDataPeriod>%s</%srealTimeDataPeriod>\n' % (namespace_, self.format_string(quote_xml(self.realTimeDataPeriod).encode(ExternalEncoding), input_name='realTimeDataPeriod'), namespace_))
        if self.beginDateTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sbeginDateTime>%s</%sbeginDateTime>\n' % (namespace_, self.format_string(quote_xml(self.beginDateTime).encode(ExternalEncoding), input_name='beginDateTime'), namespace_))
        if self.endDateTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sendDateTime>%s</%sendDateTime>\n' % (namespace_, self.format_string(quote_xml(self.endDateTime).encode(ExternalEncoding), input_name='endDateTime'), namespace_))
    def hasContent_(self):
        if (
            self.realTimeDataPeriod is not None or
            self.beginDateTime is not None or
            self.endDateTime is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimePeriodRealTimeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        TimePeriodType.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        TimePeriodType.exportLiteralChildren(self, outfile, level, name_)
        if self.realTimeDataPeriod is not None:
            showIndent(outfile, level)
            outfile.write('realTimeDataPeriod=%s,\n' % quote_python(self.realTimeDataPeriod).encode(ExternalEncoding))
        if self.beginDateTime is not None:
            showIndent(outfile, level)
            outfile.write('beginDateTime=%s,\n' % quote_python(self.beginDateTime).encode(ExternalEncoding))
        if self.endDateTime is not None:
            showIndent(outfile, level)
            outfile.write('endDateTime=%s,\n' % quote_python(self.endDateTime).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        TimePeriodType.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'realTimeDataPeriod':
            realTimeDataPeriod_ = ''
            for text__content_ in child_.childNodes:
                realTimeDataPeriod_ += text__content_.nodeValue
            self.realTimeDataPeriod = realTimeDataPeriod_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'beginDateTime':
            beginDateTime_ = ''
            for text__content_ in child_.childNodes:
                beginDateTime_ += text__content_.nodeValue
            self.beginDateTime = beginDateTime_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'endDateTime':
            endDateTime_ = ''
            for text__content_ in child_.childNodes:
                endDateTime_ += text__content_.nodeValue
            self.endDateTime = endDateTime_
        TimePeriodType.buildChildren(self, child_, nodeName_)
# end class TimePeriodRealTimeType


class GeogLocationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, srs='EPSG:4326', valueOf_=None):
        self.srs = _cast(None, srs) 
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if GeogLocationType.subclass:
            return GeogLocationType.subclass(*args_, **kwargs_)
        else:
            return GeogLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_srs(self): return self.srs
    def set_srs(self, srs): self.srs = srs
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='GeogLocationType', namespacedef_=''):
        #adjust the tag name for this xml element       
        if self.superclass.subclass == self.__class__:
            name_ = "geogLocationType"
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='GeogLocationType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='GeogLocationType'):
        if self.srs is not None:
            outfile.write(' srs=%s' % (self.format_string(quote_attrib(self.srs).encode(ExternalEncoding), input_name='srs'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GeogLocationType'):
        #if valueOf is empty, no children needs to be exported
        if not self.valueOf_: return
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeogLocationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.srs is not None:
            showIndent(outfile, level)
            outfile.write('srs = "%s",\n' % (self.srs,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('srs'):
            self.srs = attrs.get('srs').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class GeogLocationType


class LatLonPointType(GeogLocationType):
    subclass = None
    superclass = GeogLocationType
    def __init__(self, srs='EPSG:4326', latitude=None, longitude=None):
        GeogLocationType.__init__(self, srs)
        self.latitude = latitude
        self.longitude = longitude
    def factory(*args_, **kwargs_):
        if LatLonPointType.subclass:
            return LatLonPointType.subclass(*args_, **kwargs_)
        else:
            return LatLonPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def validate_latitude(self, value):
        # validate type latitude
        pass
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def validate_longitude(self, value):
        # validate type longitude
        pass
    def export(self, outfile, level, namespace_='', name_='LatLonPointType', namespacedef_=''):
        #adjust the tag name for this xml element       
        if self.superclass.subclass == self.__class__:
            name_ = "geogLocation"
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='LatLonPointType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="LatLonPointType"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='LatLonPointType'):
        GeogLocationType.exportAttributes(self, outfile, level, namespace_, name_='LatLonPointType')
    def exportChildren(self, outfile, level, namespace_='', name_='LatLonPointType'):
        GeogLocationType.exportChildren(self, outfile, level, namespace_, name_)
        if self.latitude is not None:
            showIndent(outfile, level)
            outfile.write('<%slatitude>%s</%slatitude>\n' % (namespace_, self.format_string(quote_xml(self.latitude).encode(ExternalEncoding), input_name='latitude'), namespace_))
        if self.longitude is not None:
            showIndent(outfile, level)
            outfile.write('<%slongitude>%s</%slongitude>\n' % (namespace_, self.format_string(quote_xml(self.longitude).encode(ExternalEncoding), input_name='longitude'), namespace_))
    def hasContent_(self):
        if (
            self.latitude is not None or
            self.longitude is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LatLonPointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        GeogLocationType.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        GeogLocationType.exportLiteralChildren(self, outfile, level, name_)
        if self.latitude is not None:
            showIndent(outfile, level)
            outfile.write('latitude=%s,\n' % quote_python(self.latitude).encode(ExternalEncoding))
        if self.longitude is not None:
            showIndent(outfile, level)
            outfile.write('longitude=%s,\n' % quote_python(self.longitude).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        GeogLocationType.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'latitude':
            latitude_ = ''
            for text__content_ in child_.childNodes:
                latitude_ += text__content_.nodeValue
            self.latitude = latitude_
            self.validate_latitude(self.latitude)    # validate type latitude
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'longitude':
            longitude_ = ''
            for text__content_ in child_.childNodes:
                longitude_ += text__content_.nodeValue
            self.longitude = longitude_
            self.validate_longitude(self.longitude)    # validate type longitude
        GeogLocationType.buildChildren(self, child_, nodeName_)
# end class LatLonPointType


class LatLonBoxType(GeogLocationType):
    subclass = None
    superclass = GeogLocationType
    def __init__(self, srs='EPSG:4326', south=None, west=None, north=None, east=None):
        GeogLocationType.__init__(self, srs)
        self.south = south
        self.west = west
        self.north = north
        self.east = east
    def factory(*args_, **kwargs_):
        if LatLonBoxType.subclass:
            return LatLonBoxType.subclass(*args_, **kwargs_)
        else:
            return LatLonBoxType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_south(self): return self.south
    def set_south(self, south): self.south = south
    def validate_south(self, value):
        # validate type south
        pass
    def get_west(self): return self.west
    def set_west(self, west): self.west = west
    def validate_west(self, value):
        # validate type west
        pass
    def get_north(self): return self.north
    def set_north(self, north): self.north = north
    def validate_north(self, value):
        # validate type north
        pass
    def get_east(self): return self.east
    def set_east(self, east): self.east = east
    def validate_east(self, value):
        # validate type east
        pass
    def export(self, outfile, level, namespace_='', name_='LatLonBoxType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='LatLonBoxType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="LatLonBoxType"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='LatLonBoxType'):
        GeogLocationType.exportAttributes(self, outfile, level, namespace_, name_='LatLonBoxType')
    def exportChildren(self, outfile, level, namespace_='', name_='LatLonBoxType'):
        GeogLocationType.exportChildren(self, outfile, level, namespace_, name_)
        if self.south is not None:
            showIndent(outfile, level)
            outfile.write('<%ssouth>%s</%ssouth>\n' % (namespace_, self.format_string(quote_xml(self.south).encode(ExternalEncoding), input_name='south'), namespace_))
        if self.west is not None:
            showIndent(outfile, level)
            outfile.write('<%swest>%s</%swest>\n' % (namespace_, self.format_string(quote_xml(self.west).encode(ExternalEncoding), input_name='west'), namespace_))
        if self.north is not None:
            showIndent(outfile, level)
            outfile.write('<%snorth>%s</%snorth>\n' % (namespace_, self.format_string(quote_xml(self.north).encode(ExternalEncoding), input_name='north'), namespace_))
        if self.east is not None:
            showIndent(outfile, level)
            outfile.write('<%seast>%s</%seast>\n' % (namespace_, self.format_string(quote_xml(self.east).encode(ExternalEncoding), input_name='east'), namespace_))
    def hasContent_(self):
        if (
            self.south is not None or
            self.west is not None or
            self.north is not None or
            self.east is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LatLonBoxType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        GeogLocationType.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        GeogLocationType.exportLiteralChildren(self, outfile, level, name_)
        if self.south is not None:
            showIndent(outfile, level)
            outfile.write('south=%s,\n' % quote_python(self.south).encode(ExternalEncoding))
        if self.west is not None:
            showIndent(outfile, level)
            outfile.write('west=%s,\n' % quote_python(self.west).encode(ExternalEncoding))
        if self.north is not None:
            showIndent(outfile, level)
            outfile.write('north=%s,\n' % quote_python(self.north).encode(ExternalEncoding))
        if self.east is not None:
            showIndent(outfile, level)
            outfile.write('east=%s,\n' % quote_python(self.east).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        GeogLocationType.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'south':
            south_ = ''
            for text__content_ in child_.childNodes:
                south_ += text__content_.nodeValue
            self.south = south_
            self.validate_south(self.south)    # validate type south
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'west':
            west_ = ''
            for text__content_ in child_.childNodes:
                west_ += text__content_.nodeValue
            self.west = west_
            self.validate_west(self.west)    # validate type west
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'north':
            north_ = ''
            for text__content_ in child_.childNodes:
                north_ += text__content_.nodeValue
            self.north = north_
            self.validate_north(self.north)    # validate type north
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'east':
            east_ = ''
            for text__content_ in child_.childNodes:
                east_ += text__content_.nodeValue
            self.east = east_
            self.validate_east(self.east)    # validate type east
        GeogLocationType.buildChildren(self, child_, nodeName_)
# end class LatLonBoxType


class seriesCatalogType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, menuGroupName=None, serviceWsdl=None, note=None, series=None):
        self.menuGroupName = _cast(None, menuGroupName)
        self.serviceWsdl = _cast(None, serviceWsdl)
        if note is None:
            self.note = []
        else:
            self.note = note
        if series is None:
            self.series = []
        else:
            self.series = series
    def factory(*args_, **kwargs_):
        if seriesCatalogType.subclass:
            return seriesCatalogType.subclass(*args_, **kwargs_)
        else:
            return seriesCatalogType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def get_series(self): return self.series
    def set_series(self, series): self.series = series
    def add_series(self, value): self.series.append(value)
    def insert_series(self, index, value): self.series[index] = value
    def get_menuGroupName(self): return self.menuGroupName
    def set_menuGroupName(self, menuGroupName): self.menuGroupName = menuGroupName
    def get_serviceWsdl(self): return self.serviceWsdl
    def set_serviceWsdl(self, serviceWsdl): self.serviceWsdl = serviceWsdl
    def export(self, outfile, level, namespace_='', name_='seriesCatalogType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='seriesCatalogType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='seriesCatalogType'):
        if self.menuGroupName is not None:
            outfile.write(' menuGroupName=%s' % (self.format_string(quote_attrib(self.menuGroupName).encode(ExternalEncoding), input_name='menuGroupName'), ))
        if self.serviceWsdl is not None:
            outfile.write(' serviceWsdl=%s' % (self.format_string(quote_attrib(self.serviceWsdl).encode(ExternalEncoding), input_name='serviceWsdl'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='seriesCatalogType'):
        for note_ in self.note:
            note_.export(outfile, level, namespace_, name_='note')
        for series_ in self.series:
            series_.export(outfile, level, namespace_, name_='series')
    def hasContent_(self):
        if (
            self.note or
            self.series
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='seriesCatalogType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.menuGroupName is not None:
            showIndent(outfile, level)
            outfile.write('menuGroupName = "%s",\n' % (self.menuGroupName,))
        if self.serviceWsdl is not None:
            showIndent(outfile, level)
            outfile.write('serviceWsdl = "%s",\n' % (self.serviceWsdl,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('model_.NoteType(\n')
            note_.exportLiteral(outfile, level, name_='NoteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('series=[\n')
        level += 1
        for series_ in self.series:
            showIndent(outfile, level)
            outfile.write('model_.series(\n')
            series_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('menuGroupName'):
            self.menuGroupName = attrs.get('menuGroupName').value
        if attrs.get('serviceWsdl'):
            self.serviceWsdl = attrs.get('serviceWsdl').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'note':
            obj_ = NoteType.factory()
            obj_.build(child_)
            self.note.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'series':
            obj_ = series.factory()
            obj_.build(child_)
            self.series.append(obj_)
# end class seriesCatalogType


class series(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dataType=None, variable=None, valueCount=None, variableTimeInterval=None, valueType=None, generalCategory=None, sampleMedium=None, Method=None, Source=None, QualityControlLevel=None):
        self.dataType = dataType
        self.variable = variable
        self.valueCount = valueCount
        self.variableTimeInterval = variableTimeInterval
        self.valueType = valueType
        self.generalCategory = generalCategory
        self.sampleMedium = sampleMedium
        self.Method = Method
        self.Source = Source
        self.QualityControlLevel = QualityControlLevel
    def factory(*args_, **kwargs_):
        if series.subclass:
            return series.subclass(*args_, **kwargs_)
        else:
            return series(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def validate_dataType(self, value):
        # validate type dataType
        pass
    def get_variable(self): return self.variable
    def set_variable(self, variable): self.variable = variable
    def get_valueCount(self): return self.valueCount
    def set_valueCount(self, valueCount): self.valueCount = valueCount
    def get_variableTimeInterval(self): return self.variableTimeInterval
    def set_variableTimeInterval(self, variableTimeInterval): self.variableTimeInterval = variableTimeInterval
    def get_valueType(self): return self.valueType
    def set_valueType(self, valueType): self.valueType = valueType
    def validate_valueType(self, value):
        # validate type valueType
        pass
    def get_generalCategory(self): return self.generalCategory
    def set_generalCategory(self, generalCategory): self.generalCategory = generalCategory
    def validate_generalCategory(self, value):
        # validate type generalCategory
        pass
    def get_sampleMedium(self): return self.sampleMedium
    def set_sampleMedium(self, sampleMedium): self.sampleMedium = sampleMedium
    def validate_sampleMedium(self, value):
        # validate type sampleMedium
        pass
    def get_Method(self): return self.Method
    def set_Method(self, Method): self.Method = Method
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_QualityControlLevel(self): return self.QualityControlLevel
    def set_QualityControlLevel(self, QualityControlLevel): self.QualityControlLevel = QualityControlLevel
    def export(self, outfile, level, namespace_='', name_='series', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='series')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='series'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='series'):
        if self.dataType is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataType>%s</%sdataType>\n' % (namespace_, self.format_string(quote_xml(self.dataType).encode(ExternalEncoding), input_name='dataType'), namespace_))
        if self.variable:
            self.variable.export(outfile, level, namespace_, name_='variable', )
        if self.valueCount:
            self.valueCount.export(outfile, level, namespace_, name_='valueCount', )
        if self.variableTimeInterval:
            self.variableTimeInterval.export(outfile, level, namespace_, name_='variableTimeInterval', )
        if self.valueType is not None:
            showIndent(outfile, level)
            outfile.write('<%svalueType>%s</%svalueType>\n' % (namespace_, self.format_string(quote_xml(self.valueType).encode(ExternalEncoding), input_name='valueType'), namespace_))
        if self.generalCategory is not None:
            showIndent(outfile, level)
            outfile.write('<%sgeneralCategory>%s</%sgeneralCategory>\n' % (namespace_, self.format_string(quote_xml(self.generalCategory).encode(ExternalEncoding), input_name='generalCategory'), namespace_))
        if self.sampleMedium is not None:
            showIndent(outfile, level)
            outfile.write('<%ssampleMedium>%s</%ssampleMedium>\n' % (namespace_, self.format_string(quote_xml(self.sampleMedium).encode(ExternalEncoding), input_name='sampleMedium'), namespace_))
        if self.Method:
            self.Method.export(outfile, level, namespace_, name_='Method')
        if self.Source:
            self.Source.export(outfile, level, namespace_, name_='Source')
        if self.QualityControlLevel:
            self.QualityControlLevel.export(outfile, level, namespace_, name_='QualityControlLevel')
    def hasContent_(self):
        if (
            self.dataType is not None or
            self.variable is not None or
            self.valueCount is not None or
            self.variableTimeInterval is not None or
            self.valueType is not None or
            self.generalCategory is not None or
            self.sampleMedium is not None or
            self.Method is not None or
            self.Source is not None or
            self.QualityControlLevel is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='series'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dataType is not None:
            showIndent(outfile, level)
            outfile.write('dataType=%s,\n' % quote_python(self.dataType).encode(ExternalEncoding))
        if self.variable is not None:
            showIndent(outfile, level)
            outfile.write('variable=model_.VariableInfoType(\n')
            self.variable.exportLiteral(outfile, level, name_='variable')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.valueCount is not None:
            showIndent(outfile, level)
            outfile.write('valueCount=model_.valueCount(\n')
            self.valueCount.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variableTimeInterval is not None:
            showIndent(outfile, level)
            outfile.write('variableTimeInterval=model_.TimePeriodType(\n')
            self.variableTimeInterval.exportLiteral(outfile, level, name_='variableTimeInterval')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.valueType is not None:
            showIndent(outfile, level)
            outfile.write('valueType=%s,\n' % quote_python(self.valueType).encode(ExternalEncoding))
        if self.generalCategory is not None:
            showIndent(outfile, level)
            outfile.write('generalCategory=%s,\n' % quote_python(self.generalCategory).encode(ExternalEncoding))
        if self.sampleMedium is not None:
            showIndent(outfile, level)
            outfile.write('sampleMedium=%s,\n' % quote_python(self.sampleMedium).encode(ExternalEncoding))
        if self.Method is not None:
            showIndent(outfile, level)
            outfile.write('Method=model_.MethodType(\n')
            self.Method.exportLiteral(outfile, level, name_='Method')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.SourceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.QualityControlLevel is not None:
            showIndent(outfile, level)
            outfile.write('QualityControlLevel=model_.QualityControlLevelType(\n')
            self.QualityControlLevel.exportLiteral(outfile, level, name_='QualityControlLevel')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataType':
            dataType_ = ''
            for text__content_ in child_.childNodes:
                dataType_ += text__content_.nodeValue
            self.dataType = dataType_
            self.validate_dataType(self.dataType)    # validate type dataType
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'variable':
            obj_ = VariableInfoType.factory()
            obj_.build(child_)
            self.set_variable(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'valueCount':
            obj_ = valueCount.factory()
            obj_.build(child_)
            self.set_valueCount(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'variableTimeInterval':
            obj_ = TimePeriodType.factory()
            obj_.build(child_)
            self.set_variableTimeInterval(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'valueType':
            valueType_ = ''
            for text__content_ in child_.childNodes:
                valueType_ += text__content_.nodeValue
            self.valueType = valueType_
            self.validate_valueType(self.valueType)    # validate type valueType
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'generalCategory':
            generalCategory_ = ''
            for text__content_ in child_.childNodes:
                generalCategory_ += text__content_.nodeValue
            self.generalCategory = generalCategory_
            self.validate_generalCategory(self.generalCategory)    # validate type generalCategory
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sampleMedium':
            sampleMedium_ = ''
            for text__content_ in child_.childNodes:
                sampleMedium_ += text__content_.nodeValue
            self.sampleMedium = sampleMedium_
            self.validate_sampleMedium(self.sampleMedium)    # validate type sampleMedium
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Method':
            obj_ = MethodType.factory()
            obj_.build(child_)
            self.set_Method(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Source':
            obj_ = SourceType.factory()
            obj_.build(child_)
            self.set_Source(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'QualityControlLevel':
            obj_ = QualityControlLevelType.factory()
            obj_.build(child_)
            self.set_QualityControlLevel(obj_)
# end class series


class valueCount(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, countIsEstimated=None, valueOf_=None):
        self.countIsEstimated = _cast(bool, countIsEstimated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if valueCount.subclass:
            return valueCount.subclass(*args_, **kwargs_)
        else:
            return valueCount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_countIsEstimated(self): return self.countIsEstimated
    def set_countIsEstimated(self, countIsEstimated): self.countIsEstimated = countIsEstimated
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='valueCount', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='valueCount')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='valueCount'):
        if self.countIsEstimated is not None:
            outfile.write(' countIsEstimated="%s"' % self.format_boolean(str_lower(str(self.countIsEstimated)), input_name='countIsEstimated'))
    def exportChildren(self, outfile, level, namespace_='', name_='valueCount'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='valueCount'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.countIsEstimated is not None:
            showIndent(outfile, level)
            outfile.write('countIsEstimated = %s,\n' % (self.countIsEstimated,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('countIsEstimated'):
            if attrs.get('countIsEstimated').value in ('true', '1'):
                self.countIsEstimated = True
            elif attrs.get('countIsEstimated').value in ('false', '0'):
                self.countIsEstimated = False
            else:
                raise ValueError('Bad boolean attribute (countIsEstimated)')
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class valueCount


class QualifiersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qualifier=None):
        self.qualifier = qualifier
    def factory(*args_, **kwargs_):
        if QualifiersType.subclass:
            return QualifiersType.subclass(*args_, **kwargs_)
        else:
            return QualifiersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def export(self, outfile, level, namespace_='', name_='QualifiersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='QualifiersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='QualifiersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QualifiersType'):
        if self.qualifier:
            self.qualifier.export(outfile, level, namespace_, name_='qualifier', )
    def hasContent_(self):
        if (
            self.qualifier is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QualifiersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.qualifier is not None:
            showIndent(outfile, level)
            outfile.write('qualifier=model_.qualifier(\n')
            self.qualifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'qualifier':
            obj_ = qualifier.factory()
            obj_.build(child_)
            self.set_qualifier(obj_)
# end class QualifiersType


class qualifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qualifierID=None, default=None, network=None, vocabulary=None, qualifierCode=None):
        self.qualifierID = _cast(int, qualifierID)
        self.default = _cast(bool, default)
        self.network = _cast(None, network)
        self.vocabulary = _cast(None, vocabulary)
        self.qualifierCode = qualifierCode
    def factory(*args_, **kwargs_):
        if qualifier.subclass:
            return qualifier.subclass(*args_, **kwargs_)
        else:
            return qualifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifierCode(self): return self.qualifierCode
    def set_qualifierCode(self, qualifierCode): self.qualifierCode = qualifierCode
    def get_qualifierID(self): return self.qualifierID
    def set_qualifierID(self, qualifierID): self.qualifierID = qualifierID
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def export(self, outfile, level, namespace_='', name_='qualifier', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='qualifier')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='qualifier'):
        if self.qualifierID is not None:
            outfile.write(' qualifierID="%s"' % self.format_integer(self.qualifierID, input_name='qualifierID'))
        if self.default is not None:
            outfile.write(' default="%s"' % self.format_boolean(str_lower(str(self.default)), input_name='default'))
        if self.network is not None:
            outfile.write(' network=%s' % (self.format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
        if self.vocabulary is not None:
            outfile.write(' vocabulary=%s' % (self.format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='qualifier'):
        if self.qualifierCode is not None:
            showIndent(outfile, level)
            outfile.write('<%squalifierCode>%s</%squalifierCode>\n' % (namespace_, self.format_string(quote_xml(self.qualifierCode).encode(ExternalEncoding), input_name='qualifierCode'), namespace_))
    def hasContent_(self):
        if (
            self.qualifierCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='qualifier'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.qualifierID is not None:
            showIndent(outfile, level)
            outfile.write('qualifierID = %d,\n' % (self.qualifierID,))
        if self.default is not None:
            showIndent(outfile, level)
            outfile.write('default = %s,\n' % (self.default,))
        if self.network is not None:
            showIndent(outfile, level)
            outfile.write('network = "%s",\n' % (self.network,))
        if self.vocabulary is not None:
            showIndent(outfile, level)
            outfile.write('vocabulary = "%s",\n' % (self.vocabulary,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.qualifierCode is not None:
            showIndent(outfile, level)
            outfile.write('qualifierCode=%s,\n' % quote_python(self.qualifierCode).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('qualifierID'):
            try:
                self.qualifierID = int(attrs.get('qualifierID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (qualifierID): %s' % exp)
        if attrs.get('default'):
            if attrs.get('default').value in ('true', '1'):
                self.default = True
            elif attrs.get('default').value in ('false', '0'):
                self.default = False
            else:
                raise ValueError('Bad boolean attribute (default)')
        if attrs.get('network'):
            self.network = attrs.get('network').value
        if attrs.get('vocabulary'):
            self.vocabulary = attrs.get('vocabulary').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'qualifierCode':
            qualifierCode_ = ''
            for text__content_ in child_.childNodes:
                qualifierCode_ += text__content_.nodeValue
            self.qualifierCode = qualifierCode_
# end class qualifier


class TimeSeriesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, sourceInfo=None, variable=None, values=None):
        self.name = _cast(None, name)
        self.sourceInfo = sourceInfo
        self.variable = variable
        self.values = values
    def factory(*args_, **kwargs_):
        if TimeSeriesType.subclass:
            return TimeSeriesType.subclass(*args_, **kwargs_)
        else:
            return TimeSeriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sourceInfo(self): return self.sourceInfo
    def set_sourceInfo(self, sourceInfo): self.sourceInfo = sourceInfo
    def get_variable(self): return self.variable
    def set_variable(self, variable): self.variable = variable
    def get_values(self): return self.values
    def set_values(self, values): self.values = values
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='TimeSeriesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TimeSeriesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='TimeSeriesType'):
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeSeriesType'):
        if self.sourceInfo:
            self.sourceInfo.export(outfile, level, namespace_, name_='sourceInfo', )
        if self.variable:
            self.variable.export(outfile, level, namespace_, name_='variable', )
        if self.values:
            self.values.export(outfile, level, namespace_, name_='values', )
    def hasContent_(self):
        if (
            self.sourceInfo is not None or
            self.variable is not None or
            self.values is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeSeriesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.sourceInfo is not None:
            showIndent(outfile, level)
            outfile.write('sourceInfo=model_.SourceInfoType(\n')
            self.sourceInfo.exportLiteral(outfile, level, name_='sourceInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable is not None:
            showIndent(outfile, level)
            outfile.write('variable=model_.VariableInfoType(\n')
            self.variable.exportLiteral(outfile, level, name_='variable')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.values is not None:
            showIndent(outfile, level)
            outfile.write('values=model_.TsValuesSingleVariableType(\n')
            self.values.exportLiteral(outfile, level, name_='values')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sourceInfo':
            obj_ = SourceInfoType.factory()
            obj_.build(child_)
            self.set_sourceInfo(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'variable':
            obj_ = VariableInfoType.factory()
            obj_.build(child_)
            self.set_variable(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'values':
            obj_ = TsValuesSingleVariableType.factory()
            obj_.build(child_)
            self.set_values(obj_)
# end class TimeSeriesType


class NoteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, href=None, type_=None, show=None, valueOf_=None):
        self.title = _cast(None, title)
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.show = _cast(None, show)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NoteType.subclass:
            return NoteType.subclass(*args_, **kwargs_)
        else:
            return NoteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='NoteType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='NoteType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='NoteType'):
        if self.title is not None:
            outfile.write(' title=%s' % (self.format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.href is not None:
            outfile.write(' href=%s' % (self.format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None:
            outfile.write(' type=%s' % (self.format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.show is not None:
            outfile.write(' show=%s' % (self.format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NoteType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NoteType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.href is not None:
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.show is not None:
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('title'):
            self.title = attrs.get('title').value
        if attrs.get('href'):
            self.href = attrs.get('href').value
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
        if attrs.get('show'):
            self.show = attrs.get('show').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class NoteType


class option(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, optionCode=None, optionID=None, name=None, valueOf_=None):
        self.optionCode = _cast(None, optionCode)
        self.optionID = _cast(int, optionID)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if option.subclass:
            return option.subclass(*args_, **kwargs_)
        else:
            return option(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_optionCode(self): return self.optionCode
    def set_optionCode(self, optionCode): self.optionCode = optionCode
    def get_optionID(self): return self.optionID
    def set_optionID(self, optionID): self.optionID = optionID
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='option', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='option')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='option'):
        if self.optionCode is not None:
            outfile.write(' optionCode=%s' % (self.format_string(quote_attrib(self.optionCode).encode(ExternalEncoding), input_name='optionCode'), ))
        if self.optionID is not None:
            outfile.write(' optionID="%s"' % self.format_integer(self.optionID, input_name='optionID'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='option'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='option'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.optionCode is not None:
            showIndent(outfile, level)
            outfile.write('optionCode = "%s",\n' % (self.optionCode,))
        if self.optionID is not None:
            showIndent(outfile, level)
            outfile.write('optionID = %d,\n' % (self.optionID,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('optionCode'):
            self.optionCode = attrs.get('optionCode').value
            self.optionCode = ' '.join(self.optionCode.split())
        if attrs.get('optionID'):
            try:
                self.optionID = int(attrs.get('optionID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (optionID): %s' % exp)
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class option


class variableCode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None, variableID=None, vocabulary=None, network=None, valueOf_=None):
        self.default = _cast(bool, default)
        self.variableID = _cast(int, variableID)
        self.vocabulary = _cast(None, vocabulary)
        self.network = _cast(None, network)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if variableCode.subclass:
            return variableCode.subclass(*args_, **kwargs_)
        else:
            return variableCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_variableID(self): return self.variableID
    def set_variableID(self, variableID): self.variableID = variableID
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='variableCode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='variableCode')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='variableCode'):
        if self.default is not None:
            outfile.write(' default="%s"' % self.format_boolean(str_lower(str(self.default)), input_name='default'))
        if self.variableID is not None:
            outfile.write(' variableID="%s"' % self.format_integer(self.variableID, input_name='variableID'))
        if self.vocabulary is not None:
            outfile.write(' vocabulary=%s' % (self.format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
        if self.network is not None:
            outfile.write(' network=%s' % (self.format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='variableCode'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='variableCode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.default is not None:
            showIndent(outfile, level)
            outfile.write('default = %s,\n' % (self.default,))
        if self.variableID is not None:
            showIndent(outfile, level)
            outfile.write('variableID = %d,\n' % (self.variableID,))
        if self.vocabulary is not None:
            showIndent(outfile, level)
            outfile.write('vocabulary = "%s",\n' % (self.vocabulary,))
        if self.network is not None:
            showIndent(outfile, level)
            outfile.write('network = "%s",\n' % (self.network,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('default'):
            if attrs.get('default').value in ('true', '1'):
                self.default = True
            elif attrs.get('default').value in ('false', '0'):
                self.default = False
            else:
                raise ValueError('Bad boolean attribute (default)')
        if attrs.get('variableID'):
            try:
                self.variableID = int(attrs.get('variableID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (variableID): %s' % exp)
        if attrs.get('vocabulary'):
            self.vocabulary = attrs.get('vocabulary').value
        if attrs.get('network'):
            self.network = attrs.get('network').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class variableCode


class units(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitsAbbreviation=None, unitsCode=None, unitsType=None, valueOf_=None):
        self.unitsAbbreviation = _cast(None, unitsAbbreviation)
        self.unitsCode = _cast(None, unitsCode)
        self.unitsType = _cast(None, unitsType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if units.subclass:
            return units.subclass(*args_, **kwargs_)
        else:
            return units(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitsAbbreviation(self): return self.unitsAbbreviation
    def set_unitsAbbreviation(self, unitsAbbreviation): self.unitsAbbreviation = unitsAbbreviation
    def get_unitsCode(self): return self.unitsCode
    def set_unitsCode(self, unitsCode): self.unitsCode = unitsCode
    def get_unitsType(self): return self.unitsType
    def set_unitsType(self, unitsType): self.unitsType = unitsType
    def validate_UnitsTypeEnum(self, value):
        # Validate type UnitsTypeEnum, a restriction on xsi:string.
        pass
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='units', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='units')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='units'):
        if self.unitsAbbreviation is not None:
            outfile.write(' unitsAbbreviation=%s' % (self.format_string(quote_attrib(self.unitsAbbreviation).encode(ExternalEncoding), input_name='unitsAbbreviation'), ))
        if self.unitsCode is not None:
            outfile.write(' unitsCode=%s' % (self.format_string(quote_attrib(self.unitsCode).encode(ExternalEncoding), input_name='unitsCode'), ))
        if self.unitsType is not None:
            outfile.write(' unitsType=%s' % (quote_attrib(self.unitsType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='units'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='units'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.unitsAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('unitsAbbreviation = "%s",\n' % (self.unitsAbbreviation,))
        if self.unitsCode is not None:
            showIndent(outfile, level)
            outfile.write('unitsCode = "%s",\n' % (self.unitsCode,))
        if self.unitsType is not None:
            showIndent(outfile, level)
            outfile.write('unitsType = "%s",\n' % (self.unitsType,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('unitsAbbreviation'):
            self.unitsAbbreviation = attrs.get('unitsAbbreviation').value
        if attrs.get('unitsCode'):
            self.unitsCode = attrs.get('unitsCode').value
            self.unitsCode = ' '.join(self.unitsCode.split())
        if attrs.get('unitsType'):
            self.unitsType = attrs.get('unitsType').value
            self.validate_UnitsTypeEnum(self.unitsType)    # validate type UnitsTypeEnum
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class units


class ValueSingleVariable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codedVocabularyTerm=None, metadataDateTime=None, qualityControlLevel=None, methodID=None, codedVocabulary=None, sourceID=None, oid=None, censorCode=None, offsetDescription=None, sampleID=None, offsetTypeID=None, accuracyStdDev=None, offsetUnitsAbbreviation=None, offsetValue=None, dateTime=None, qualifiers=None, offsetUnitsCode=None, valueOf_=None):
        self.codedVocabularyTerm = _cast(None, codedVocabularyTerm)
        self.metadataDateTime = _cast(None, metadataDateTime)
        self.qualityControlLevel = _cast(None, qualityControlLevel)
        self.methodID = _cast(int, methodID)
        self.codedVocabulary = _cast(bool, codedVocabulary)
        self.sourceID = _cast(int, sourceID)
        self.oid = _cast(None, oid)
        self.censorCode = _cast(None, censorCode)
        self.offsetDescription = _cast(None, offsetDescription)
        self.sampleID = _cast(int, sampleID)
        self.offsetTypeID = _cast(int, offsetTypeID)
        self.accuracyStdDev = _cast(float, accuracyStdDev)
        self.offsetUnitsAbbreviation = _cast(None, offsetUnitsAbbreviation)
        self.offsetValue = _cast(float, offsetValue)
        self.dateTime = _cast(None, dateTime)
        self.qualifiers = _cast(None, qualifiers)
        self.offsetUnitsCode = _cast(None, offsetUnitsCode)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ValueSingleVariable.subclass:
            return ValueSingleVariable.subclass(*args_, **kwargs_)
        else:
            return ValueSingleVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codedVocabularyTerm(self): return self.codedVocabularyTerm
    def set_codedVocabularyTerm(self, codedVocabularyTerm): self.codedVocabularyTerm = codedVocabularyTerm
    def get_metadataDateTime(self): return self.metadataDateTime
    def set_metadataDateTime(self, metadataDateTime): self.metadataDateTime = metadataDateTime
    def get_qualityControlLevel(self): return self.qualityControlLevel
    def set_qualityControlLevel(self, qualityControlLevel): self.qualityControlLevel = qualityControlLevel
    def validate_QualityControlLevelEnum(self, value):
        # Validate type QualityControlLevelEnum, a restriction on xsi:string.
        pass
    def get_methodID(self): return self.methodID
    def set_methodID(self, methodID): self.methodID = methodID
    def get_codedVocabulary(self): return self.codedVocabulary
    def set_codedVocabulary(self, codedVocabulary): self.codedVocabulary = codedVocabulary
    def get_sourceID(self): return self.sourceID
    def set_sourceID(self, sourceID): self.sourceID = sourceID
    def get_oid(self): return self.oid
    def set_oid(self, oid): self.oid = oid
    def get_censorCode(self): return self.censorCode
    def set_censorCode(self, censorCode): self.censorCode = censorCode
    def validate_CensorCodeEnum(self, value):
        # Validate type CensorCodeEnum, a restriction on xsi:string.
        pass
    def get_offsetDescription(self): return self.offsetDescription
    def set_offsetDescription(self, offsetDescription): self.offsetDescription = offsetDescription
    def get_sampleID(self): return self.sampleID
    def set_sampleID(self, sampleID): self.sampleID = sampleID
    def get_offsetTypeID(self): return self.offsetTypeID
    def set_offsetTypeID(self, offsetTypeID): self.offsetTypeID = offsetTypeID
    def get_accuracyStdDev(self): return self.accuracyStdDev
    def set_accuracyStdDev(self, accuracyStdDev): self.accuracyStdDev = accuracyStdDev
    def get_offsetUnitsAbbreviation(self): return self.offsetUnitsAbbreviation
    def set_offsetUnitsAbbreviation(self, offsetUnitsAbbreviation): self.offsetUnitsAbbreviation = offsetUnitsAbbreviation
    def get_offsetValue(self): return self.offsetValue
    def set_offsetValue(self, offsetValue): self.offsetValue = offsetValue
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_qualifiers(self): return self.qualifiers
    def set_qualifiers(self, qualifiers): self.qualifiers = qualifiers
    def get_offsetUnitsCode(self): return self.offsetUnitsCode
    def set_offsetUnitsCode(self, offsetUnitsCode): self.offsetUnitsCode = offsetUnitsCode
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='ValueSingleVariable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ValueSingleVariable')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ValueSingleVariable'):
        if self.codedVocabularyTerm is not None:
            outfile.write(' codedVocabularyTerm=%s' % (self.format_string(quote_attrib(self.codedVocabularyTerm).encode(ExternalEncoding), input_name='codedVocabularyTerm'), ))
        if self.metadataDateTime is not None:
            outfile.write(' metadataDateTime=%s' % (self.format_string(quote_attrib(self.metadataDateTime).encode(ExternalEncoding), input_name='metadataDateTime'), ))
        if self.qualityControlLevel is not None:
            outfile.write(' qualityControlLevel=%s' % (quote_attrib(self.qualityControlLevel), ))
        if self.methodID is not None:
            outfile.write(' methodID="%s"' % self.format_integer(self.methodID, input_name='methodID'))
        if self.codedVocabulary is not None:
            outfile.write(' codedVocabulary="%s"' % self.format_boolean(str_lower(str(self.codedVocabulary)), input_name='codedVocabulary'))
        if self.sourceID is not None:
            outfile.write(' sourceID="%s"' % self.format_integer(self.sourceID, input_name='sourceID'))
        if self.oid is not None:
            outfile.write(' oid=%s' % (self.format_string(quote_attrib(self.oid).encode(ExternalEncoding), input_name='oid'), ))
        if self.censorCode is not None:
            outfile.write(' censorCode=%s' % (quote_attrib(self.censorCode), ))
        if self.offsetDescription is not None:
            outfile.write(' offsetDescription=%s' % (self.format_string(quote_attrib(self.offsetDescription).encode(ExternalEncoding), input_name='offsetDescription'), ))
        if self.sampleID is not None:
            outfile.write(' sampleID="%s"' % self.format_integer(self.sampleID, input_name='sampleID'))
        if self.offsetTypeID is not None:
            outfile.write(' offsetTypeID="%s"' % self.format_integer(self.offsetTypeID, input_name='offsetTypeID'))
        if self.accuracyStdDev is not None:
            outfile.write(' accuracyStdDev="%s"' % self.format_double(self.accuracyStdDev, input_name='accuracyStdDev'))
        if self.offsetUnitsAbbreviation is not None:
            outfile.write(' offsetUnitsAbbreviation=%s' % (self.format_string(quote_attrib(self.offsetUnitsAbbreviation).encode(ExternalEncoding), input_name='offsetUnitsAbbreviation'), ))
        if self.offsetValue is not None:
            outfile.write(' offsetValue="%s"' % self.format_double(self.offsetValue, input_name='offsetValue'))
        outfile.write(' dateTime=%s' % (self.format_string(quote_attrib(self.dateTime).encode(ExternalEncoding), input_name='dateTime'), ))
        if self.qualifiers is not None:
            outfile.write(' qualifiers=%s' % (self.format_string(quote_attrib(self.qualifiers).encode(ExternalEncoding), input_name='qualifiers'), ))
        if self.offsetUnitsCode is not None:
            outfile.write(' offsetUnitsCode=%s' % (self.format_string(quote_attrib(self.offsetUnitsCode).encode(ExternalEncoding), input_name='offsetUnitsCode'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ValueSingleVariable'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueSingleVariable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.codedVocabularyTerm is not None:
            showIndent(outfile, level)
            outfile.write('codedVocabularyTerm = "%s",\n' % (self.codedVocabularyTerm,))
        if self.metadataDateTime is not None:
            showIndent(outfile, level)
            outfile.write('metadataDateTime = "%s",\n' % (self.metadataDateTime,))
        if self.qualityControlLevel is not None:
            showIndent(outfile, level)
            outfile.write('qualityControlLevel = "%s",\n' % (self.qualityControlLevel,))
        if self.methodID is not None:
            showIndent(outfile, level)
            outfile.write('methodID = %d,\n' % (self.methodID,))
        if self.codedVocabulary is not None:
            showIndent(outfile, level)
            outfile.write('codedVocabulary = %s,\n' % (self.codedVocabulary,))
        if self.sourceID is not None:
            showIndent(outfile, level)
            outfile.write('sourceID = %d,\n' % (self.sourceID,))
        if self.oid is not None:
            showIndent(outfile, level)
            outfile.write('oid = "%s",\n' % (self.oid,))
        if self.censorCode is not None:
            showIndent(outfile, level)
            outfile.write('censorCode = "%s",\n' % (self.censorCode,))
        if self.offsetDescription is not None:
            showIndent(outfile, level)
            outfile.write('offsetDescription = "%s",\n' % (self.offsetDescription,))
        if self.sampleID is not None:
            showIndent(outfile, level)
            outfile.write('sampleID = %d,\n' % (self.sampleID,))
        if self.offsetTypeID is not None:
            showIndent(outfile, level)
            outfile.write('offsetTypeID = %d,\n' % (self.offsetTypeID,))
        if self.accuracyStdDev is not None:
            showIndent(outfile, level)
            outfile.write('accuracyStdDev = %e,\n' % (self.accuracyStdDev,))
        if self.offsetUnitsAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('offsetUnitsAbbreviation = "%s",\n' % (self.offsetUnitsAbbreviation,))
        if self.offsetValue is not None:
            showIndent(outfile, level)
            outfile.write('offsetValue = %e,\n' % (self.offsetValue,))
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime = "%s",\n' % (self.dateTime,))
        if self.qualifiers is not None:
            showIndent(outfile, level)
            outfile.write('qualifiers = "%s",\n' % (self.qualifiers,))
        if self.offsetUnitsCode is not None:
            showIndent(outfile, level)
            outfile.write('offsetUnitsCode = "%s",\n' % (self.offsetUnitsCode,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('codedVocabularyTerm'):
            self.codedVocabularyTerm = attrs.get('codedVocabularyTerm').value
        if attrs.get('metadataDateTime'):
            self.metadataDateTime = attrs.get('metadataDateTime').value
        if attrs.get('qualityControlLevel'):
            self.qualityControlLevel = attrs.get('qualityControlLevel').value
            self.validate_QualityControlLevelEnum(self.qualityControlLevel)    # validate type QualityControlLevelEnum
        if attrs.get('methodID'):
            try:
                self.methodID = int(attrs.get('methodID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (methodID): %s' % exp)
        if attrs.get('codedVocabulary'):
            if attrs.get('codedVocabulary').value in ('true', '1'):
                self.codedVocabulary = True
            elif attrs.get('codedVocabulary').value in ('false', '0'):
                self.codedVocabulary = False
            else:
                raise ValueError('Bad boolean attribute (codedVocabulary)')
        if attrs.get('sourceID'):
            try:
                self.sourceID = int(attrs.get('sourceID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (sourceID): %s' % exp)
        if attrs.get('oid'):
            self.oid = attrs.get('oid').value
        if attrs.get('censorCode'):
            self.censorCode = attrs.get('censorCode').value
            self.validate_CensorCodeEnum(self.censorCode)    # validate type CensorCodeEnum
        if attrs.get('offsetDescription'):
            self.offsetDescription = attrs.get('offsetDescription').value
        if attrs.get('sampleID'):
            try:
                self.sampleID = int(attrs.get('sampleID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (sampleID): %s' % exp)
        if attrs.get('offsetTypeID'):
            try:
                self.offsetTypeID = int(attrs.get('offsetTypeID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (offsetTypeID): %s' % exp)
        if attrs.get('accuracyStdDev'):
            try:
                self.accuracyStdDev = float(attrs.get('accuracyStdDev').value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (accuracyStdDev): %s' % exp)
        if attrs.get('offsetUnitsAbbreviation'):
            self.offsetUnitsAbbreviation = attrs.get('offsetUnitsAbbreviation').value
        if attrs.get('offsetValue'):
            try:
                self.offsetValue = float(attrs.get('offsetValue').value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (offsetValue): %s' % exp)
        if attrs.get('dateTime'):
            self.dateTime = attrs.get('dateTime').value
        if attrs.get('qualifiers'):
            self.qualifiers = attrs.get('qualifiers').value
        if attrs.get('offsetUnitsCode'):
            self.offsetUnitsCode = attrs.get('offsetUnitsCode').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class ValueSingleVariable


class VariablesResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, queryInfo=None, variables=None):
        self.queryInfo = queryInfo
        self.variables = variables
    def factory(*args_, **kwargs_):
        if VariablesResponseType.subclass:
            return VariablesResponseType.subclass(*args_, **kwargs_)
        else:
            return VariablesResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_queryInfo(self): return self.queryInfo
    def set_queryInfo(self, queryInfo): self.queryInfo = queryInfo
    def get_variables(self): return self.variables
    def set_variables(self, variables): self.variables = variables
    def export(self, outfile, level, namespace_='', name_='variablesResponse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='variablesResponse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='variablesResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='variablesResponse'):
        if self.queryInfo:
            self.queryInfo.export(outfile, level, namespace_, name_='queryInfo', )
        if self.variables:
            self.variables.export(outfile, level, namespace_, name_='variables', )
    def hasContent_(self):
        if (
            self.queryInfo is not None or
            self.variables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='variablesResponse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.queryInfo is not None:
            showIndent(outfile, level)
            outfile.write('queryInfo=model_.QueryInfoType(\n')
            self.queryInfo.exportLiteral(outfile, level, name_='queryInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variables is not None:
            showIndent(outfile, level)
            outfile.write('variables=model_.variables(\n')
            self.variables.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'queryInfo':
            obj_ = QueryInfoType.factory()
            obj_.build(child_)
            self.set_queryInfo(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'variables':
            obj_ = variables.factory()
            obj_.build(child_)
            self.set_variables(obj_)
# end class VariablesResponseType


class TimeSeriesResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, queryInfo=None, timeSeries=None):
        self.queryInfo = queryInfo
        self.timeSeries = timeSeries
    def factory(*args_, **kwargs_):
        if TimeSeriesResponseType.subclass:
            return TimeSeriesResponseType.subclass(*args_, **kwargs_)
        else:
            return TimeSeriesResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_queryInfo(self): return self.queryInfo
    def set_queryInfo(self, queryInfo): self.queryInfo = queryInfo
    def get_timeSeries(self): return self.timeSeries
    def set_timeSeries(self, timeSeries): self.timeSeries = timeSeries
    def export(self, outfile, level, namespace_='', name_='timeSeriesResponse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='timeSeriesResponse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='timeSeriesResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='timeSeriesResponse'):
        if self.queryInfo:
            self.queryInfo.export(outfile, level, namespace_, name_='queryInfo', )
        if self.timeSeries:
            self.timeSeries.export(outfile, level, namespace_, name_='timeSeries', )
    def hasContent_(self):
        if (
            self.queryInfo is not None or
            self.timeSeries is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='timeSeriesResponse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.queryInfo is not None:
            showIndent(outfile, level)
            outfile.write('queryInfo=model_.QueryInfoType(\n')
            self.queryInfo.exportLiteral(outfile, level, name_='queryInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timeSeries is not None:
            showIndent(outfile, level)
            outfile.write('timeSeries=model_.TimeSeriesType(\n')
            self.timeSeries.exportLiteral(outfile, level, name_='timeSeries')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'queryInfo':
            obj_ = QueryInfoType.factory()
            obj_.build(child_)
            self.set_queryInfo(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timeSeries':
            obj_ = TimeSeriesType.factory()
            obj_.build(child_)
            self.set_timeSeries(obj_)
# end class TimeSeriesResponseType


class SiteInfoResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, queryInfo=None, site=None):
        self.queryInfo = queryInfo
        if site is None:
            self.site = []
        else:
            self.site = site
    def factory(*args_, **kwargs_):
        if SiteInfoResponseType.subclass:
            return SiteInfoResponseType.subclass(*args_, **kwargs_)
        else:
            return SiteInfoResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_queryInfo(self): return self.queryInfo
    def set_queryInfo(self, queryInfo): self.queryInfo = queryInfo
    def get_site(self): return self.site
    def set_site(self, site): self.site = site
    def add_site(self, value): self.site.append(value)
    def insert_site(self, index, value): self.site[index] = value
    def export(self, outfile, level, namespace_='', name_='sitesResponse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sitesResponse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='sitesResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='sitesResponse'):
        if self.queryInfo:
            self.queryInfo.export(outfile, level, namespace_, name_='queryInfo', )
        for site_ in self.site:
            site_.export(outfile, level, namespace_, name_='site')
    def hasContent_(self):
        if (
            self.queryInfo is not None or
            self.site
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sitesResponse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.queryInfo is not None:
            showIndent(outfile, level)
            outfile.write('queryInfo=model_.QueryInfoType(\n')
            self.queryInfo.exportLiteral(outfile, level, name_='queryInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('site=[\n')
        level += 1
        for site_ in self.site:
            showIndent(outfile, level)
            outfile.write('model_.site(\n')
            site_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'queryInfo':
            obj_ = QueryInfoType.factory()
            obj_.build(child_)
            self.set_queryInfo(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'site':
            obj_ = site.factory()
            obj_.build(child_)
            self.site.append(obj_)
# end class SiteInfoResponseType


class site(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, siteInfo=None, seriesCatalog=None, extension=None):
        self.siteInfo = siteInfo
        if seriesCatalog is None:
            self.seriesCatalog = []
        else:
            self.seriesCatalog = seriesCatalog
        self.extension = extension
    def factory(*args_, **kwargs_):
        if site.subclass:
            return site.subclass(*args_, **kwargs_)
        else:
            return site(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_siteInfo(self): return self.siteInfo
    def set_siteInfo(self, siteInfo): self.siteInfo = siteInfo
    def get_seriesCatalog(self): return self.seriesCatalog
    def set_seriesCatalog(self, seriesCatalog): self.seriesCatalog = seriesCatalog
    def add_seriesCatalog(self, value): self.seriesCatalog.append(value)
    def insert_seriesCatalog(self, index, value): self.seriesCatalog[index] = value
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def export(self, outfile, level, namespace_='', name_='site', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='site')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='site'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='site'):
        if self.siteInfo:
            self.siteInfo.export(outfile, level, namespace_, name_='siteInfo', )
        for seriesCatalog_ in self.seriesCatalog:
            seriesCatalog_.export(outfile, level, namespace_, name_='seriesCatalog')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('<%sextension>%s</%sextension>\n' % (namespace_, self.format_string(quote_xml(self.extension).encode(ExternalEncoding), input_name='extension'), namespace_))
    def hasContent_(self):
        if (
            self.siteInfo is not None or
            self.seriesCatalog or
            self.extension is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='site'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.siteInfo is not None:
            showIndent(outfile, level)
            outfile.write('siteInfo=model_.SiteInfoType(\n')
            self.siteInfo.exportLiteral(outfile, level, name_='siteInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('seriesCatalog=[\n')
        level += 1
        for seriesCatalog_ in self.seriesCatalog:
            showIndent(outfile, level)
            outfile.write('model_.seriesCatalogType(\n')
            seriesCatalog_.exportLiteral(outfile, level, name_='seriesCatalogType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('extension=%s,\n' % quote_python(self.extension).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'siteInfo':
            obj_ = SiteInfoType.factory()
            obj_.build(child_)
            self.set_siteInfo(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'seriesCatalog':
            obj_ = seriesCatalogType.factory()
            obj_.build(child_)
            self.seriesCatalog.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extension':
            extension_ = ''
            for text__content_ in child_.childNodes:
                extension_ += text__content_.nodeValue
            self.extension = extension_
# end class site


class qualityControlLevel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, metadataDateTime=None, network=None, vocabulary=None, qualityControlLevelCode=None, oid=None, default=None, qualityControlLevelID=None):
        self.metadataDateTime = _cast(None, metadataDateTime)
        self.network = _cast(None, network)
        self.vocabulary = _cast(None, vocabulary)
        self.qualityControlLevelCode = _cast(None, qualityControlLevelCode)
        self.oid = _cast(None, oid)
        self.default = _cast(bool, default)
        self.qualityControlLevelID = qualityControlLevelID
    def factory(*args_, **kwargs_):
        if qualityControlLevel.subclass:
            return qualityControlLevel.subclass(*args_, **kwargs_)
        else:
            return qualityControlLevel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualityControlLevelID(self): return self.qualityControlLevelID
    def set_qualityControlLevelID(self, qualityControlLevelID): self.qualityControlLevelID = qualityControlLevelID
    def get_metadataDateTime(self): return self.metadataDateTime
    def set_metadataDateTime(self, metadataDateTime): self.metadataDateTime = metadataDateTime
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_qualityControlLevelCode(self): return self.qualityControlLevelCode
    def set_qualityControlLevelCode(self, qualityControlLevelCode): self.qualityControlLevelCode = qualityControlLevelCode
    def get_oid(self): return self.oid
    def set_oid(self, oid): self.oid = oid
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def export(self, outfile, level, namespace_='', name_='qualityControlLevel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='qualityControlLevel')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='qualityControlLevel'):
        if self.metadataDateTime is not None:
            outfile.write(' metadataDateTime=%s' % (self.format_string(quote_attrib(self.metadataDateTime).encode(ExternalEncoding), input_name='metadataDateTime'), ))
        if self.network is not None:
            outfile.write(' network=%s' % (self.format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
        if self.vocabulary is not None:
            outfile.write(' vocabulary=%s' % (self.format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
        if self.qualityControlLevelCode is not None:
            outfile.write(' qualityControlLevelCode=%s' % (self.format_string(quote_attrib(self.qualityControlLevelCode).encode(ExternalEncoding), input_name='qualityControlLevelCode'), ))
        if self.oid is not None:
            outfile.write(' oid=%s' % (self.format_string(quote_attrib(self.oid).encode(ExternalEncoding), input_name='oid'), ))
        if self.default is not None:
            outfile.write(' default="%s"' % self.format_boolean(str_lower(str(self.default)), input_name='default'))
    def exportChildren(self, outfile, level, namespace_='', name_='qualityControlLevel'):
        if self.qualityControlLevelID is not None:
            showIndent(outfile, level)
            outfile.write('<%squalityControlLevelID>%s</%squalityControlLevelID>\n' % (namespace_, self.format_string(quote_xml(self.qualityControlLevelID).encode(ExternalEncoding), input_name='qualityControlLevelID'), namespace_))
    def hasContent_(self):
        if (
            self.qualityControlLevelID is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='qualityControlLevel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.metadataDateTime is not None:
            showIndent(outfile, level)
            outfile.write('metadataDateTime = "%s",\n' % (self.metadataDateTime,))
        if self.network is not None:
            showIndent(outfile, level)
            outfile.write('network = "%s",\n' % (self.network,))
        if self.vocabulary is not None:
            showIndent(outfile, level)
            outfile.write('vocabulary = "%s",\n' % (self.vocabulary,))
        if self.qualityControlLevelCode is not None:
            showIndent(outfile, level)
            outfile.write('qualityControlLevelCode = "%s",\n' % (self.qualityControlLevelCode,))
        if self.oid is not None:
            showIndent(outfile, level)
            outfile.write('oid = "%s",\n' % (self.oid,))
        if self.default is not None:
            showIndent(outfile, level)
            outfile.write('default = %s,\n' % (self.default,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.qualityControlLevelID is not None:
            showIndent(outfile, level)
            outfile.write('qualityControlLevelID=%s,\n' % quote_python(self.qualityControlLevelID).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('metadataDateTime'):
            self.metadataDateTime = attrs.get('metadataDateTime').value
        if attrs.get('network'):
            self.network = attrs.get('network').value
        if attrs.get('vocabulary'):
            self.vocabulary = attrs.get('vocabulary').value
        if attrs.get('qualityControlLevelCode'):
            self.qualityControlLevelCode = attrs.get('qualityControlLevelCode').value
        if attrs.get('oid'):
            self.oid = attrs.get('oid').value
        if attrs.get('default'):
            if attrs.get('default').value in ('true', '1'):
                self.default = True
            elif attrs.get('default').value in ('false', '0'):
                self.default = False
            else:
                raise ValueError('Bad boolean attribute (default)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'qualityControlLevelID':
            qualityControlLevelID_ = ''
            for text__content_ in child_.childNodes:
                qualityControlLevelID_ += text__content_.nodeValue
            self.qualityControlLevelID = qualityControlLevelID_
# end class qualityControlLevel


class QualityControlLevelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qualityControlLevelID=None, valueOf_=None):
        self.qualityControlLevelID = _cast(int, qualityControlLevelID)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if QualityControlLevelType.subclass:
            return QualityControlLevelType.subclass(*args_, **kwargs_)
        else:
            return QualityControlLevelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualityControlLevelID(self): return self.qualityControlLevelID
    def set_qualityControlLevelID(self, qualityControlLevelID): self.qualityControlLevelID = qualityControlLevelID
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='QualityControlLevelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='QualityControlLevelType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='QualityControlLevelType'):
        if self.qualityControlLevelID is not None:
            outfile.write(' qualityControlLevelID="%s"' % self.format_integer(self.qualityControlLevelID, input_name='qualityControlLevelID'))
    def exportChildren(self, outfile, level, namespace_='', name_='QualityControlLevelType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QualityControlLevelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.qualityControlLevelID is not None:
            showIndent(outfile, level)
            outfile.write('qualityControlLevelID = %d,\n' % (self.qualityControlLevelID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('qualityControlLevelID'):
            try:
                self.qualityControlLevelID = int(attrs.get('qualityControlLevelID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (qualityControlLevelID): %s' % exp)
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class QualityControlLevelType


class UnitsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UnitID=None, UnitName=None, UnitDescription=None, UnitType=None, UnitAbbreviation=None):
        self.UnitID = _cast(int, UnitID)
        self.UnitName = UnitName
        self.UnitDescription = UnitDescription
        self.UnitType = UnitType
        self.UnitAbbreviation = UnitAbbreviation
    def factory(*args_, **kwargs_):
        if UnitsType.subclass:
            return UnitsType.subclass(*args_, **kwargs_)
        else:
            return UnitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitName(self): return self.UnitName
    def set_UnitName(self, UnitName): self.UnitName = UnitName
    def get_UnitDescription(self): return self.UnitDescription
    def set_UnitDescription(self, UnitDescription): self.UnitDescription = UnitDescription
    def get_UnitType(self): return self.UnitType
    def set_UnitType(self, UnitType): self.UnitType = UnitType
    def validate_UnitType(self, value):
        # validate type UnitType
        pass
    def get_UnitAbbreviation(self): return self.UnitAbbreviation
    def set_UnitAbbreviation(self, UnitAbbreviation): self.UnitAbbreviation = UnitAbbreviation
    def get_UnitID(self): return self.UnitID
    def set_UnitID(self, UnitID): self.UnitID = UnitID
    def export(self, outfile, level, namespace_='', name_='UnitsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='UnitsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='UnitsType'):
        if self.UnitID is not None:
            outfile.write(' UnitID="%s"' % self.format_integer(self.UnitID, input_name='UnitID'))
    def exportChildren(self, outfile, level, namespace_='', name_='UnitsType'):
        if self.UnitName is not None:
            showIndent(outfile, level)
            outfile.write('<%sUnitName>%s</%sUnitName>\n' % (namespace_, self.format_string(quote_xml(self.UnitName).encode(ExternalEncoding), input_name='UnitName'), namespace_))
        if self.UnitDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sUnitDescription>%s</%sUnitDescription>\n' % (namespace_, self.format_string(quote_xml(self.UnitDescription).encode(ExternalEncoding), input_name='UnitDescription'), namespace_))
        if self.UnitType is not None:
            showIndent(outfile, level)
            outfile.write('<%sUnitType>%s</%sUnitType>\n' % (namespace_, self.format_string(quote_xml(self.UnitType).encode(ExternalEncoding), input_name='UnitType'), namespace_))
        if self.UnitAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('<%sUnitAbbreviation>%s</%sUnitAbbreviation>\n' % (namespace_, self.format_string(quote_xml(self.UnitAbbreviation).encode(ExternalEncoding), input_name='UnitAbbreviation'), namespace_))
    def hasContent_(self):
        if (
            self.UnitName is not None or
            self.UnitDescription is not None or
            self.UnitType is not None or
            self.UnitAbbreviation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UnitsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.UnitID is not None:
            showIndent(outfile, level)
            outfile.write('UnitID = %d,\n' % (self.UnitID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitName is not None:
            showIndent(outfile, level)
            outfile.write('UnitName=%s,\n' % quote_python(self.UnitName).encode(ExternalEncoding))
        if self.UnitDescription is not None:
            showIndent(outfile, level)
            outfile.write('UnitDescription=%s,\n' % quote_python(self.UnitDescription).encode(ExternalEncoding))
        if self.UnitType is not None:
            showIndent(outfile, level)
            outfile.write('UnitType=%s,\n' % quote_python(self.UnitType).encode(ExternalEncoding))
        if self.UnitAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('UnitAbbreviation=%s,\n' % quote_python(self.UnitAbbreviation).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('UnitID'):
            try:
                self.UnitID = int(attrs.get('UnitID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (UnitID): %s' % exp)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'UnitName':
            UnitName_ = ''
            for text__content_ in child_.childNodes:
                UnitName_ += text__content_.nodeValue
            self.UnitName = UnitName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'UnitDescription':
            UnitDescription_ = ''
            for text__content_ in child_.childNodes:
                UnitDescription_ += text__content_.nodeValue
            self.UnitDescription = UnitDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'UnitType':
            UnitType_ = ''
            for text__content_ in child_.childNodes:
                UnitType_ += text__content_.nodeValue
            self.UnitType = UnitType_
            self.validate_UnitType(self.UnitType)    # validate type UnitType
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'UnitAbbreviation':
            UnitAbbreviation_ = ''
            for text__content_ in child_.childNodes:
                UnitAbbreviation_ += text__content_.nodeValue
            self.UnitAbbreviation = UnitAbbreviation_
# end class UnitsType


class MethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, methodID=None, MethodDescription=None, MethodLink=None):
        self.methodID = _cast(int, methodID)
        self.MethodDescription = MethodDescription
        self.MethodLink = MethodLink
    def factory(*args_, **kwargs_):
        if MethodType.subclass:
            return MethodType.subclass(*args_, **kwargs_)
        else:
            return MethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MethodDescription(self): return self.MethodDescription
    def set_MethodDescription(self, MethodDescription): self.MethodDescription = MethodDescription
    def get_MethodLink(self): return self.MethodLink
    def set_MethodLink(self, MethodLink): self.MethodLink = MethodLink
    def get_methodID(self): return self.methodID
    def set_methodID(self, methodID): self.methodID = methodID
    def export(self, outfile, level, namespace_='', name_='MethodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='MethodType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='MethodType'):
        if self.methodID is not None:
            outfile.write(' methodID="%s"' % self.format_integer(self.methodID, input_name='methodID'))
    def exportChildren(self, outfile, level, namespace_='', name_='MethodType'):
        if self.MethodDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sMethodDescription>%s</%sMethodDescription>\n' % (namespace_, self.format_string(quote_xml(self.MethodDescription).encode(ExternalEncoding), input_name='MethodDescription'), namespace_))
        if self.MethodLink is not None:
            showIndent(outfile, level)
            outfile.write('<%sMethodLink>%s</%sMethodLink>\n' % (namespace_, self.format_string(quote_xml(self.MethodLink).encode(ExternalEncoding), input_name='MethodLink'), namespace_))
    def hasContent_(self):
        if (
            self.MethodDescription is not None or
            self.MethodLink is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MethodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.methodID is not None:
            showIndent(outfile, level)
            outfile.write('methodID = %d,\n' % (self.methodID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MethodDescription is not None:
            showIndent(outfile, level)
            outfile.write('MethodDescription=%s,\n' % quote_python(self.MethodDescription).encode(ExternalEncoding))
        if self.MethodLink is not None:
            showIndent(outfile, level)
            outfile.write('MethodLink=%s,\n' % quote_python(self.MethodLink).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('methodID'):
            try:
                self.methodID = int(attrs.get('methodID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (methodID): %s' % exp)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'MethodDescription':
            MethodDescription_ = ''
            for text__content_ in child_.childNodes:
                MethodDescription_ += text__content_.nodeValue
            self.MethodDescription = MethodDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'MethodLink':
            MethodLink_ = ''
            for text__content_ in child_.childNodes:
                MethodLink_ += text__content_.nodeValue
            self.MethodLink = MethodLink_
# end class MethodType


class SampleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sampleID=None, labSampleCode=None, SampleType=None, LabMethod=None):
        self.sampleID = _cast(int, sampleID)
        self.labSampleCode = labSampleCode
        self.SampleType = SampleType
        self.LabMethod = LabMethod
    def factory(*args_, **kwargs_):
        if SampleType.subclass:
            return SampleType.subclass(*args_, **kwargs_)
        else:
            return SampleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_labSampleCode(self): return self.labSampleCode
    def set_labSampleCode(self, labSampleCode): self.labSampleCode = labSampleCode
    def get_SampleType(self): return self.SampleType
    def set_SampleType(self, SampleType): self.SampleType = SampleType
    def validate_SampleType(self, value):
        # validate type SampleType
        pass
    def get_LabMethod(self): return self.LabMethod
    def set_LabMethod(self, LabMethod): self.LabMethod = LabMethod
    def get_sampleID(self): return self.sampleID
    def set_sampleID(self, sampleID): self.sampleID = sampleID
    def export(self, outfile, level, namespace_='', name_='SampleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SampleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='SampleType'):
        if self.sampleID is not None:
            outfile.write(' sampleID="%s"' % self.format_integer(self.sampleID, input_name='sampleID'))
    def exportChildren(self, outfile, level, namespace_='', name_='SampleType'):
        if self.labSampleCode is not None:
            showIndent(outfile, level)
            outfile.write('<%slabSampleCode>%s</%slabSampleCode>\n' % (namespace_, self.format_string(quote_xml(self.labSampleCode).encode(ExternalEncoding), input_name='labSampleCode'), namespace_))
        if self.SampleType is not None:
            showIndent(outfile, level)
            outfile.write('<%sSampleType>%s</%sSampleType>\n' % (namespace_, self.format_string(quote_xml(self.SampleType).encode(ExternalEncoding), input_name='SampleType'), namespace_))
        if self.LabMethod:
            self.LabMethod.export(outfile, level, namespace_, name_='LabMethod')
    def hasContent_(self):
        if (
            self.labSampleCode is not None or
            self.SampleType is not None or
            self.LabMethod is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SampleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.sampleID is not None:
            showIndent(outfile, level)
            outfile.write('sampleID = %d,\n' % (self.sampleID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.labSampleCode is not None:
            showIndent(outfile, level)
            outfile.write('labSampleCode=%s,\n' % quote_python(self.labSampleCode).encode(ExternalEncoding))
        if self.SampleType is not None:
            showIndent(outfile, level)
            outfile.write('SampleType=%s,\n' % quote_python(self.SampleType).encode(ExternalEncoding))
        if self.LabMethod is not None:
            showIndent(outfile, level)
            outfile.write('LabMethod=model_.LabMethodType(\n')
            self.LabMethod.exportLiteral(outfile, level, name_='LabMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('sampleID'):
            try:
                self.sampleID = int(attrs.get('sampleID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (sampleID): %s' % exp)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'labSampleCode':
            labSampleCode_ = ''
            for text__content_ in child_.childNodes:
                labSampleCode_ += text__content_.nodeValue
            self.labSampleCode = labSampleCode_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'SampleType':
            SampleType_ = ''
            for text__content_ in child_.childNodes:
                SampleType_ += text__content_.nodeValue
            self.SampleType = SampleType_
            self.validate_SampleType(self.SampleType)    # validate type SampleType
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'LabMethod':
            obj_ = LabMethodType.factory()
            obj_.build(child_)
            self.set_LabMethod(obj_)
# end class SampleType


class LabMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, labMethodID=None, labName=None, labOrganization=None, LabMethodName=None, labMethodDescription=None, labMethodLink=None):
        self.labMethodID = _cast(int, labMethodID)
        self.labName = labName
        self.labOrganization = labOrganization
        self.LabMethodName = LabMethodName
        self.labMethodDescription = labMethodDescription
        self.labMethodLink = labMethodLink
    def factory(*args_, **kwargs_):
        if LabMethodType.subclass:
            return LabMethodType.subclass(*args_, **kwargs_)
        else:
            return LabMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_labName(self): return self.labName
    def set_labName(self, labName): self.labName = labName
    def get_labOrganization(self): return self.labOrganization
    def set_labOrganization(self, labOrganization): self.labOrganization = labOrganization
    def get_LabMethodName(self): return self.LabMethodName
    def set_LabMethodName(self, LabMethodName): self.LabMethodName = LabMethodName
    def get_labMethodDescription(self): return self.labMethodDescription
    def set_labMethodDescription(self, labMethodDescription): self.labMethodDescription = labMethodDescription
    def get_labMethodLink(self): return self.labMethodLink
    def set_labMethodLink(self, labMethodLink): self.labMethodLink = labMethodLink
    def get_labMethodID(self): return self.labMethodID
    def set_labMethodID(self, labMethodID): self.labMethodID = labMethodID
    def export(self, outfile, level, namespace_='', name_='LabMethodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='LabMethodType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='LabMethodType'):
        if self.labMethodID is not None:
            outfile.write(' labMethodID="%s"' % self.format_integer(self.labMethodID, input_name='labMethodID'))
    def exportChildren(self, outfile, level, namespace_='', name_='LabMethodType'):
        if self.labName is not None:
            showIndent(outfile, level)
            outfile.write('<%slabName>%s</%slabName>\n' % (namespace_, self.format_string(quote_xml(self.labName).encode(ExternalEncoding), input_name='labName'), namespace_))
        if self.labOrganization is not None:
            showIndent(outfile, level)
            outfile.write('<%slabOrganization>%s</%slabOrganization>\n' % (namespace_, self.format_string(quote_xml(self.labOrganization).encode(ExternalEncoding), input_name='labOrganization'), namespace_))
        if self.LabMethodName is not None:
            showIndent(outfile, level)
            outfile.write('<%sLabMethodName>%s</%sLabMethodName>\n' % (namespace_, self.format_string(quote_xml(self.LabMethodName).encode(ExternalEncoding), input_name='LabMethodName'), namespace_))
        if self.labMethodDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%slabMethodDescription>%s</%slabMethodDescription>\n' % (namespace_, self.format_string(quote_xml(self.labMethodDescription).encode(ExternalEncoding), input_name='labMethodDescription'), namespace_))
        if self.labMethodLink is not None:
            showIndent(outfile, level)
            outfile.write('<%slabMethodLink>%s</%slabMethodLink>\n' % (namespace_, self.format_string(quote_xml(self.labMethodLink).encode(ExternalEncoding), input_name='labMethodLink'), namespace_))
    def hasContent_(self):
        if (
            self.labName is not None or
            self.labOrganization is not None or
            self.LabMethodName is not None or
            self.labMethodDescription is not None or
            self.labMethodLink is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LabMethodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.labMethodID is not None:
            showIndent(outfile, level)
            outfile.write('labMethodID = %d,\n' % (self.labMethodID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.labName is not None:
            showIndent(outfile, level)
            outfile.write('labName=%s,\n' % quote_python(self.labName).encode(ExternalEncoding))
        if self.labOrganization is not None:
            showIndent(outfile, level)
            outfile.write('labOrganization=%s,\n' % quote_python(self.labOrganization).encode(ExternalEncoding))
        if self.LabMethodName is not None:
            showIndent(outfile, level)
            outfile.write('LabMethodName=%s,\n' % quote_python(self.LabMethodName).encode(ExternalEncoding))
        if self.labMethodDescription is not None:
            showIndent(outfile, level)
            outfile.write('labMethodDescription=%s,\n' % quote_python(self.labMethodDescription).encode(ExternalEncoding))
        if self.labMethodLink is not None:
            showIndent(outfile, level)
            outfile.write('labMethodLink=%s,\n' % quote_python(self.labMethodLink).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('labMethodID'):
            try:
                self.labMethodID = int(attrs.get('labMethodID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (labMethodID): %s' % exp)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'labName':
            labName_ = ''
            for text__content_ in child_.childNodes:
                labName_ += text__content_.nodeValue
            self.labName = labName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'labOrganization':
            labOrganization_ = ''
            for text__content_ in child_.childNodes:
                labOrganization_ += text__content_.nodeValue
            self.labOrganization = labOrganization_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'LabMethodName':
            LabMethodName_ = ''
            for text__content_ in child_.childNodes:
                LabMethodName_ += text__content_.nodeValue
            self.LabMethodName = LabMethodName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'labMethodDescription':
            labMethodDescription_ = ''
            for text__content_ in child_.childNodes:
                labMethodDescription_ += text__content_.nodeValue
            self.labMethodDescription = labMethodDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'labMethodLink':
            labMethodLink_ = ''
            for text__content_ in child_.childNodes:
                labMethodLink_ += text__content_.nodeValue
            self.labMethodLink = labMethodLink_
# end class LabMethodType


class SourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sourceID=None, Organization=None, SourceDescription=None, Metadata=None, ContactInformation=None, SourceLink=None):
        self.sourceID = _cast(int, sourceID)
        self.Organization = Organization
        self.SourceDescription = SourceDescription
        self.Metadata = Metadata
        self.ContactInformation = ContactInformation
        self.SourceLink = SourceLink
    def factory(*args_, **kwargs_):
        if SourceType.subclass:
            return SourceType.subclass(*args_, **kwargs_)
        else:
            return SourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Organization(self): return self.Organization
    def set_Organization(self, Organization): self.Organization = Organization
    def get_SourceDescription(self): return self.SourceDescription
    def set_SourceDescription(self, SourceDescription): self.SourceDescription = SourceDescription
    def get_Metadata(self): return self.Metadata
    def set_Metadata(self, Metadata): self.Metadata = Metadata
    def get_ContactInformation(self): return self.ContactInformation
    def set_ContactInformation(self, ContactInformation): self.ContactInformation = ContactInformation
    def get_SourceLink(self): return self.SourceLink
    def set_SourceLink(self, SourceLink): self.SourceLink = SourceLink
    def get_sourceID(self): return self.sourceID
    def set_sourceID(self, sourceID): self.sourceID = sourceID
    def export(self, outfile, level, namespace_='', name_='SourceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SourceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='SourceType'):
        if self.sourceID is not None:
            outfile.write(' sourceID="%s"' % self.format_integer(self.sourceID, input_name='sourceID'))
    def exportChildren(self, outfile, level, namespace_='', name_='SourceType'):
        if self.Organization is not None:
            showIndent(outfile, level)
            outfile.write('<%sOrganization>%s</%sOrganization>\n' % (namespace_, self.format_string(quote_xml(self.Organization).encode(ExternalEncoding), input_name='Organization'), namespace_))
        if self.SourceDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sSourceDescription>%s</%sSourceDescription>\n' % (namespace_, self.format_string(quote_xml(self.SourceDescription).encode(ExternalEncoding), input_name='SourceDescription'), namespace_))
        if self.Metadata:
            self.Metadata.export(outfile, level, namespace_, name_='Metadata')
        if self.ContactInformation:
            self.ContactInformation.export(outfile, level, namespace_, name_='ContactInformation')
        if self.SourceLink is not None:
            showIndent(outfile, level)
            outfile.write('<%sSourceLink>%s</%sSourceLink>\n' % (namespace_, self.format_string(quote_xml(self.SourceLink).encode(ExternalEncoding), input_name='SourceLink'), namespace_))
    def hasContent_(self):
        if (
            self.Organization is not None or
            self.SourceDescription is not None or
            self.Metadata is not None or
            self.ContactInformation is not None or
            self.SourceLink is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.sourceID is not None:
            showIndent(outfile, level)
            outfile.write('sourceID = %d,\n' % (self.sourceID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Organization is not None:
            showIndent(outfile, level)
            outfile.write('Organization=%s,\n' % quote_python(self.Organization).encode(ExternalEncoding))
        if self.SourceDescription is not None:
            showIndent(outfile, level)
            outfile.write('SourceDescription=%s,\n' % quote_python(self.SourceDescription).encode(ExternalEncoding))
        if self.Metadata is not None:
            showIndent(outfile, level)
            outfile.write('Metadata=model_.MetaDataType(\n')
            self.Metadata.exportLiteral(outfile, level, name_='Metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContactInformation is not None:
            showIndent(outfile, level)
            outfile.write('ContactInformation=model_.ContactInformationType(\n')
            self.ContactInformation.exportLiteral(outfile, level, name_='ContactInformation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SourceLink is not None:
            showIndent(outfile, level)
            outfile.write('SourceLink=%s,\n' % quote_python(self.SourceLink).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('sourceID'):
            try:
                self.sourceID = int(attrs.get('sourceID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (sourceID): %s' % exp)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Organization':
            Organization_ = ''
            for text__content_ in child_.childNodes:
                Organization_ += text__content_.nodeValue
            self.Organization = Organization_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'SourceDescription':
            SourceDescription_ = ''
            for text__content_ in child_.childNodes:
                SourceDescription_ += text__content_.nodeValue
            self.SourceDescription = SourceDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Metadata':
            obj_ = MetaDataType.factory()
            obj_.build(child_)
            self.set_Metadata(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ContactInformation':
            obj_ = ContactInformationType.factory()
            obj_.build(child_)
            self.set_ContactInformation(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'SourceLink':
            SourceLink_ = ''
            for text__content_ in child_.childNodes:
                SourceLink_ += text__content_.nodeValue
            self.SourceLink = SourceLink_
# end class SourceType


class ContactInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ContactName=None, TypeOfContact=None, Phone=None, Email=None, Address=None):
        self.ContactName = ContactName
        self.TypeOfContact = TypeOfContact
        self.Phone = Phone
        self.Email = Email
        self.Address = Address
    def factory(*args_, **kwargs_):
        if ContactInformationType.subclass:
            return ContactInformationType.subclass(*args_, **kwargs_)
        else:
            return ContactInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactName(self): return self.ContactName
    def set_ContactName(self, ContactName): self.ContactName = ContactName
    def get_TypeOfContact(self): return self.TypeOfContact
    def set_TypeOfContact(self, TypeOfContact): self.TypeOfContact = TypeOfContact
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def get_Email(self): return self.Email
    def set_Email(self, Email): self.Email = Email
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def export(self, outfile, level, namespace_='', name_='ContactInformationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ContactInformationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ContactInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactInformationType'):
        if self.ContactName is not None:
            showIndent(outfile, level)
            outfile.write('<%sContactName>%s</%sContactName>\n' % (namespace_, self.format_string(quote_xml(self.ContactName).encode(ExternalEncoding), input_name='ContactName'), namespace_))
        if self.TypeOfContact is not None:
            showIndent(outfile, level)
            outfile.write('<%sTypeOfContact>%s</%sTypeOfContact>\n' % (namespace_, self.format_string(quote_xml(self.TypeOfContact).encode(ExternalEncoding), input_name='TypeOfContact'), namespace_))
        if self.Phone is not None:
            showIndent(outfile, level)
            outfile.write('<%sPhone>%s</%sPhone>\n' % (namespace_, self.format_string(quote_xml(self.Phone).encode(ExternalEncoding), input_name='Phone'), namespace_))
        if self.Email is not None:
            showIndent(outfile, level)
            outfile.write('<%sEmail>%s</%sEmail>\n' % (namespace_, self.format_string(quote_xml(self.Email).encode(ExternalEncoding), input_name='Email'), namespace_))
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('<%sAddress>%s</%sAddress>\n' % (namespace_, self.format_string(quote_xml(self.Address).encode(ExternalEncoding), input_name='Address'), namespace_))
    def hasContent_(self):
        if (
            self.ContactName is not None or
            self.TypeOfContact is not None or
            self.Phone is not None or
            self.Email is not None or
            self.Address is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContactInformationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ContactName is not None:
            showIndent(outfile, level)
            outfile.write('ContactName=%s,\n' % quote_python(self.ContactName).encode(ExternalEncoding))
        if self.TypeOfContact is not None:
            showIndent(outfile, level)
            outfile.write('TypeOfContact=%s,\n' % quote_python(self.TypeOfContact).encode(ExternalEncoding))
        if self.Phone is not None:
            showIndent(outfile, level)
            outfile.write('Phone=%s,\n' % quote_python(self.Phone).encode(ExternalEncoding))
        if self.Email is not None:
            showIndent(outfile, level)
            outfile.write('Email=%s,\n' % quote_python(self.Email).encode(ExternalEncoding))
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=%s,\n' % quote_python(self.Address).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ContactName':
            ContactName_ = ''
            for text__content_ in child_.childNodes:
                ContactName_ += text__content_.nodeValue
            self.ContactName = ContactName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'TypeOfContact':
            TypeOfContact_ = ''
            for text__content_ in child_.childNodes:
                TypeOfContact_ += text__content_.nodeValue
            self.TypeOfContact = TypeOfContact_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Phone':
            Phone_ = ''
            for text__content_ in child_.childNodes:
                Phone_ += text__content_.nodeValue
            self.Phone = Phone_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Email':
            Email_ = ''
            for text__content_ in child_.childNodes:
                Email_ += text__content_.nodeValue
            self.Email = Email_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Address':
            Address_ = ''
            for text__content_ in child_.childNodes:
                Address_ += text__content_.nodeValue
            self.Address = Address_
# end class ContactInformationType


class MetaDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TopicCategory=None, Title=None, Abstract=None, ProfileVersion=None, MetadataLink=None):
        self.TopicCategory = TopicCategory
        self.Title = Title
        self.Abstract = Abstract
        self.ProfileVersion = ProfileVersion
        self.MetadataLink = MetadataLink
    def factory(*args_, **kwargs_):
        if MetaDataType.subclass:
            return MetaDataType.subclass(*args_, **kwargs_)
        else:
            return MetaDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopicCategory(self): return self.TopicCategory
    def set_TopicCategory(self, TopicCategory): self.TopicCategory = TopicCategory
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_Abstract(self): return self.Abstract
    def set_Abstract(self, Abstract): self.Abstract = Abstract
    def get_ProfileVersion(self): return self.ProfileVersion
    def set_ProfileVersion(self, ProfileVersion): self.ProfileVersion = ProfileVersion
    def get_MetadataLink(self): return self.MetadataLink
    def set_MetadataLink(self, MetadataLink): self.MetadataLink = MetadataLink
    def export(self, outfile, level, namespace_='', name_='MetaDataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='MetaDataType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='MetaDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MetaDataType'):
        if self.TopicCategory is not None:
            showIndent(outfile, level)
            outfile.write('<%sTopicCategory>%s</%sTopicCategory>\n' % (namespace_, self.format_string(quote_xml(self.TopicCategory).encode(ExternalEncoding), input_name='TopicCategory'), namespace_))
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('<%sTitle>%s</%sTitle>\n' % (namespace_, self.format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_))
        if self.Abstract is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbstract>%s</%sAbstract>\n' % (namespace_, self.format_string(quote_xml(self.Abstract).encode(ExternalEncoding), input_name='Abstract'), namespace_))
        if self.ProfileVersion is not None:
            showIndent(outfile, level)
            outfile.write('<%sProfileVersion>%s</%sProfileVersion>\n' % (namespace_, self.format_string(quote_xml(self.ProfileVersion).encode(ExternalEncoding), input_name='ProfileVersion'), namespace_))
        if self.MetadataLink is not None:
            showIndent(outfile, level)
            outfile.write('<%sMetadataLink>%s</%sMetadataLink>\n' % (namespace_, self.format_string(quote_xml(self.MetadataLink).encode(ExternalEncoding), input_name='MetadataLink'), namespace_))
    def hasContent_(self):
        if (
            self.TopicCategory is not None or
            self.Title is not None or
            self.Abstract is not None or
            self.ProfileVersion is not None or
            self.MetadataLink is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MetaDataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TopicCategory is not None:
            showIndent(outfile, level)
            outfile.write('TopicCategory=%s,\n' % quote_python(self.TopicCategory).encode(ExternalEncoding))
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.Abstract is not None:
            showIndent(outfile, level)
            outfile.write('Abstract=%s,\n' % quote_python(self.Abstract).encode(ExternalEncoding))
        if self.ProfileVersion is not None:
            showIndent(outfile, level)
            outfile.write('ProfileVersion=%s,\n' % quote_python(self.ProfileVersion).encode(ExternalEncoding))
        if self.MetadataLink is not None:
            showIndent(outfile, level)
            outfile.write('MetadataLink=%s,\n' % quote_python(self.MetadataLink).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'TopicCategory':
            TopicCategory_ = ''
            for text__content_ in child_.childNodes:
                TopicCategory_ += text__content_.nodeValue
            self.TopicCategory = TopicCategory_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Title':
            Title_ = ''
            for text__content_ in child_.childNodes:
                Title_ += text__content_.nodeValue
            self.Title = Title_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'Abstract':
            Abstract_ = ''
            for text__content_ in child_.childNodes:
                Abstract_ += text__content_.nodeValue
            self.Abstract = Abstract_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ProfileVersion':
            ProfileVersion_ = ''
            for text__content_ in child_.childNodes:
                ProfileVersion_ += text__content_.nodeValue
            self.ProfileVersion = ProfileVersion_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'MetadataLink':
            MetadataLink_ = ''
            for text__content_ in child_.childNodes:
                MetadataLink_ += text__content_.nodeValue
            self.MetadataLink = MetadataLink_
# end class MetaDataType


class OffsetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, offsetTypeID=None, offsetValue=None, offsetDescription=None, units=None, offsetIsVertical='true', offsetHorizDirectionDegrees=None):
        self.offsetTypeID = _cast(int, offsetTypeID)
        self.offsetValue = offsetValue
        self.offsetDescription = offsetDescription
        self.units = units
        self.offsetIsVertical = offsetIsVertical
        self.offsetHorizDirectionDegrees = offsetHorizDirectionDegrees
    def factory(*args_, **kwargs_):
        if OffsetType.subclass:
            return OffsetType.subclass(*args_, **kwargs_)
        else:
            return OffsetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_offsetValue(self): return self.offsetValue
    def set_offsetValue(self, offsetValue): self.offsetValue = offsetValue
    def get_offsetDescription(self): return self.offsetDescription
    def set_offsetDescription(self, offsetDescription): self.offsetDescription = offsetDescription
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_offsetIsVertical(self): return self.offsetIsVertical
    def set_offsetIsVertical(self, offsetIsVertical): self.offsetIsVertical = offsetIsVertical
    def get_offsetHorizDirectionDegrees(self): return self.offsetHorizDirectionDegrees
    def set_offsetHorizDirectionDegrees(self, offsetHorizDirectionDegrees): self.offsetHorizDirectionDegrees = offsetHorizDirectionDegrees
    def get_offsetTypeID(self): return self.offsetTypeID
    def set_offsetTypeID(self, offsetTypeID): self.offsetTypeID = offsetTypeID
    def export(self, outfile, level, namespace_='', name_='OffsetType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='OffsetType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='OffsetType'):
        if self.offsetTypeID is not None:
            outfile.write(' offsetTypeID="%s"' % self.format_integer(self.offsetTypeID, input_name='offsetTypeID'))
    def exportChildren(self, outfile, level, namespace_='', name_='OffsetType'):
        if self.offsetValue is not None:
            showIndent(outfile, level)
            outfile.write('<%soffsetValue>%s</%soffsetValue>\n' % (namespace_, self.format_string(quote_xml(self.offsetValue).encode(ExternalEncoding), input_name='offsetValue'), namespace_))
        if self.offsetDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%soffsetDescription>%s</%soffsetDescription>\n' % (namespace_, self.format_string(quote_xml(self.offsetDescription).encode(ExternalEncoding), input_name='offsetDescription'), namespace_))
        if self.units:
            self.units.export(outfile, level, namespace_, name_='units', )
        if self.offsetIsVertical is not None:
            showIndent(outfile, level)
            outfile.write('<%soffsetIsVertical>%s</%soffsetIsVertical>\n' % (namespace_, self.format_string(quote_xml(self.offsetIsVertical).encode(ExternalEncoding), input_name='offsetIsVertical'), namespace_))
        if self.offsetHorizDirectionDegrees is not None:
            showIndent(outfile, level)
            outfile.write('<%soffsetHorizDirectionDegrees>%s</%soffsetHorizDirectionDegrees>\n' % (namespace_, self.format_string(quote_xml(self.offsetHorizDirectionDegrees).encode(ExternalEncoding), input_name='offsetHorizDirectionDegrees'), namespace_))
    def hasContent_(self):
        if (
            self.offsetValue is not None or
            self.offsetDescription is not None or
            self.units is not None or
            self.offsetIsVertical is not None or
            self.offsetHorizDirectionDegrees is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OffsetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.offsetTypeID is not None:
            showIndent(outfile, level)
            outfile.write('offsetTypeID = %d,\n' % (self.offsetTypeID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.offsetValue is not None:
            showIndent(outfile, level)
            outfile.write('offsetValue=%s,\n' % quote_python(self.offsetValue).encode(ExternalEncoding))
        if self.offsetDescription is not None:
            showIndent(outfile, level)
            outfile.write('offsetDescription=%s,\n' % quote_python(self.offsetDescription).encode(ExternalEncoding))
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('units=model_.units(\n')
            self.units.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.offsetIsVertical is not None:
            showIndent(outfile, level)
            outfile.write('offsetIsVertical=%s,\n' % quote_python(self.offsetIsVertical).encode(ExternalEncoding))
        if self.offsetHorizDirectionDegrees is not None:
            showIndent(outfile, level)
            outfile.write('offsetHorizDirectionDegrees=%s,\n' % quote_python(self.offsetHorizDirectionDegrees).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('offsetTypeID'):
            try:
                self.offsetTypeID = int(attrs.get('offsetTypeID').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (offsetTypeID): %s' % exp)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'offsetValue':
            offsetValue_ = ''
            for text__content_ in child_.childNodes:
                offsetValue_ += text__content_.nodeValue
            self.offsetValue = offsetValue_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'offsetDescription':
            offsetDescription_ = ''
            for text__content_ in child_.childNodes:
                offsetDescription_ += text__content_.nodeValue
            self.offsetDescription = offsetDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'units':
            obj_ = units.factory()
            obj_.build(child_)
            self.set_units(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'offsetIsVertical':
            offsetIsVertical_ = ''
            for text__content_ in child_.childNodes:
                offsetIsVertical_ += text__content_.nodeValue
            self.offsetIsVertical = offsetIsVertical_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'offsetHorizDirectionDegrees':
            offsetHorizDirectionDegrees_ = ''
            for text__content_ in child_.childNodes:
                offsetHorizDirectionDegrees_ += text__content_.nodeValue
            self.offsetHorizDirectionDegrees = offsetHorizDirectionDegrees_
# end class OffsetType


class SiteInfoType(SourceInfoType):
    subclass = None
    superclass = SourceInfoType
    def __init__(self, metadataDateTime=None, oid=None, siteName=None, siteCode=None, timeZoneInfo=None, geoLocation=None, elevation_m=None, verticalDatum=None, note=None, extension=None, altname=None):
        SourceInfoType.__init__(self)
        self.metadataDateTime = _cast(None, metadataDateTime)
        self.oid = _cast(None, oid)
        self.siteName = siteName
        if siteCode is None:
            self.siteCode = []
        else:
            self.siteCode = siteCode
        self.timeZoneInfo = timeZoneInfo
        self.geoLocation = geoLocation
        self.elevation_m = elevation_m
        self.verticalDatum = verticalDatum
        if note is None:
            self.note = []
        else:
            self.note = note
        self.extension = extension
        self.altname = altname
    def factory(*args_, **kwargs_):
        if SiteInfoType.subclass:
            return SiteInfoType.subclass(*args_, **kwargs_)
        else:
            return SiteInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_siteName(self): return self.siteName
    def set_siteName(self, siteName): self.siteName = siteName
    def get_siteCode(self): return self.siteCode
    def set_siteCode(self, siteCode): self.siteCode = siteCode
    def add_siteCode(self, value): self.siteCode.append(value)
    def insert_siteCode(self, index, value): self.siteCode[index] = value
    def get_timeZoneInfo(self): return self.timeZoneInfo
    def set_timeZoneInfo(self, timeZoneInfo): self.timeZoneInfo = timeZoneInfo
    def get_geoLocation(self): return self.geoLocation
    def set_geoLocation(self, geoLocation): self.geoLocation = geoLocation
    def get_elevation_m(self): return self.elevation_m
    def set_elevation_m(self, elevation_m): self.elevation_m = elevation_m
    def get_verticalDatum(self): return self.verticalDatum
    def set_verticalDatum(self, verticalDatum): self.verticalDatum = verticalDatum
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_altname(self): return self.altname
    def set_altname(self, altname): self.altname = altname
    def get_metadataDateTime(self): return self.metadataDateTime
    def set_metadataDateTime(self, metadataDateTime): self.metadataDateTime = metadataDateTime
    def get_oid(self): return self.oid
    def set_oid(self, oid): self.oid = oid
    def export(self, outfile, level, namespace_='', name_='SiteInfoType', namespacedef_=''):
        #adjust the tag name for this xml element       
        if self.superclass.subclass == self.__class__:
            name_ = "sourceInfo"
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SiteInfoType')
        #outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="SiteInfoType"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='SiteInfoType'):
        SourceInfoType.exportAttributes(self, outfile, level, namespace_, name_='SiteInfoType')
        if self.metadataDateTime is not None:
            outfile.write(' metadataDateTime=%s' % (self.format_string(quote_attrib(self.metadataDateTime).encode(ExternalEncoding), input_name='metadataDateTime'), ))
        if self.oid is not None:
            outfile.write(' oid=%s' % (self.format_string(quote_attrib(self.oid).encode(ExternalEncoding), input_name='oid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SiteInfoType'):
        SourceInfoType.exportChildren(self, outfile, level, namespace_, name_)
        if self.siteName is not None:
            showIndent(outfile, level)
            outfile.write('<%ssiteName>%s</%ssiteName>\n' % (namespace_, self.format_string(quote_xml(self.siteName).encode(ExternalEncoding), input_name='siteName'), namespace_))
        for siteCode_ in self.siteCode:
            siteCode_.export(outfile, level, namespace_, name_='siteCode')
        if self.timeZoneInfo:
            self.timeZoneInfo.export(outfile, level, namespace_, name_='timeZoneInfo')
        if self.geoLocation:
            self.geoLocation.export(outfile, level, namespace_, name_='geoLocation')
        if self.elevation_m is not None:
            showIndent(outfile, level)
            outfile.write('<%selevation_m>%s</%selevation_m>\n' % (namespace_, self.format_string(quote_xml(self.elevation_m).encode(ExternalEncoding), input_name='elevation_m'), namespace_))
        if self.verticalDatum is not None:
            showIndent(outfile, level)
            outfile.write('<%sverticalDatum>%s</%sverticalDatum>\n' % (namespace_, self.format_string(quote_xml(self.verticalDatum).encode(ExternalEncoding), input_name='verticalDatum'), namespace_))
        for note_ in self.note:
            note_.export(outfile, level, namespace_, name_='note')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('<%sextension>%s</%sextension>\n' % (namespace_, self.format_string(quote_xml(self.extension).encode(ExternalEncoding), input_name='extension'), namespace_))
        if self.altname is not None:
            showIndent(outfile, level)
            outfile.write('<%saltname>%s</%saltname>\n' % (namespace_, self.format_string(quote_xml(self.altname).encode(ExternalEncoding), input_name='altname'), namespace_))
    def hasContent_(self):
        if (
            self.siteName is not None or
            self.siteCode or
            self.timeZoneInfo is not None or
            self.geoLocation is not None or
            self.elevation_m is not None or
            self.verticalDatum is not None or
            self.note or
            self.extension is not None or
            self.altname is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SiteInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.metadataDateTime is not None:
            showIndent(outfile, level)
            outfile.write('metadataDateTime = "%s",\n' % (self.metadataDateTime,))
        if self.oid is not None:
            showIndent(outfile, level)
            outfile.write('oid = "%s",\n' % (self.oid,))
        SourceInfoType.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        SourceInfoType.exportLiteralChildren(self, outfile, level, name_)
        if self.siteName is not None:
            showIndent(outfile, level)
            outfile.write('siteName=%s,\n' % quote_python(self.siteName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('siteCode=[\n')
        level += 1
        for siteCode_ in self.siteCode:
            showIndent(outfile, level)
            outfile.write('model_.siteCode(\n')
            siteCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.timeZoneInfo is not None:
            showIndent(outfile, level)
            outfile.write('timeZoneInfo=model_.timeZoneInfo(\n')
            self.timeZoneInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.geoLocation is not None:
            showIndent(outfile, level)
            outfile.write('geoLocation=model_.geoLocation(\n')
            self.geoLocation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.elevation_m is not None:
            showIndent(outfile, level)
            outfile.write('elevation_m=%s,\n' % quote_python(self.elevation_m).encode(ExternalEncoding))
        if self.verticalDatum is not None:
            showIndent(outfile, level)
            outfile.write('verticalDatum=%s,\n' % quote_python(self.verticalDatum).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('model_.NoteType(\n')
            note_.exportLiteral(outfile, level, name_='NoteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.extension is not None:
            showIndent(outfile, level)
            outfile.write('extension=%s,\n' % quote_python(self.extension).encode(ExternalEncoding))
        if self.altname is not None:
            showIndent(outfile, level)
            outfile.write('altname=%s,\n' % quote_python(self.altname).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('metadataDateTime'):
            self.metadataDateTime = attrs.get('metadataDateTime').value
        if attrs.get('oid'):
            self.oid = attrs.get('oid').value
        SourceInfoType.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'siteName':
            siteName_ = ''
            for text__content_ in child_.childNodes:
                siteName_ += text__content_.nodeValue
            self.siteName = siteName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'siteCode':
            obj_ = siteCode.factory()
            obj_.build(child_)
            self.siteCode.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timeZoneInfo':
            obj_ = timeZoneInfo.factory()
            obj_.build(child_)
            self.set_timeZoneInfo(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'geoLocation':
            obj_ = geoLocation.factory()
            obj_.build(child_)
            self.set_geoLocation(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'elevation_m':
            elevation_m_ = ''
            for text__content_ in child_.childNodes:
                elevation_m_ += text__content_.nodeValue
            self.elevation_m = elevation_m_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'verticalDatum':
            verticalDatum_ = ''
            for text__content_ in child_.childNodes:
                verticalDatum_ += text__content_.nodeValue
            self.verticalDatum = verticalDatum_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'note':
            obj_ = NoteType.factory()
            obj_.build(child_)
            self.note.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extension':
            extension_ = ''
            for text__content_ in child_.childNodes:
                extension_ += text__content_.nodeValue
            self.extension = extension_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'altname':
            altname_ = ''
            for text__content_ in child_.childNodes:
                altname_ += text__content_.nodeValue
            self.altname = altname_
        SourceInfoType.buildChildren(self, child_, nodeName_)
# end class SiteInfoType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = SiteInfoType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="SiteInfoType", 
        namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = SiteInfoType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="SiteInfoType",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = SiteInfoType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from cuashi import *\n\n')
    sys.stdout.write('import cuashi as model_\n\n')
    sys.stdout.write('rootObj = model_.SiteInfoType(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_="SiteInfoType")
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

